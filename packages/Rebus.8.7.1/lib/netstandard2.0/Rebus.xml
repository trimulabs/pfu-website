<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handlers are wanted
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport,Rebus.Time.IRebusTime)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables saga auditing which will cause Rebus to save a snapshot of each saga state to the configured snapshot storage.
            Please remember to select a saga snapshot storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableSagaAuditing().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            The implementations of the advanced APIs are private classes inside <see cref="T:Rebus.Bus.RebusBus"/> so that they can access private functions and stuff
            </summary>
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Bus.BusLifetimeEvents,Rebus.DataBus.IDataBus,Rebus.Topic.ITopicNameConvention,Rebus.Time.IRebusTime)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            (or the name used when configuring it, if the name has been customized)
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.DataBus">
            <summary>
            Gets the API for the data bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.SyncBus">
            <summary>
            Exposes a synchronous version of <see cref="T:Rebus.Bus.IBus"/> that essentially mimics all APIs only providing them in a synchronous version
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.SendRoutingSlip(Rebus.Routing.Itinerary,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the message as a routing slip that will visit the destinations specified by the given <see cref="T:Rebus.Routing.Itinerary"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Defer(System.String,System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>,
            delaying delivery approximately by the time specified by <paramref name="delay"/>.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ISyncBus">
            <summary>
            Synchronous API for all of the async-native operations of the Rebus <see cref="T:Rebus.Bus.IBus"/>. May be used in applications 
            that need to perform bus operations deep within a call hierarchy, or that simply do not contain an appropriate place
            to await something. Safe to use in applications that insist on running continuations on the initiating thread, like 
            e.g. ASP.NET and WPF.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.SendLocal(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Send(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Reply(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Publish(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="T:Rebus.Bus.BusLifetimeEvents">
            <summary>
            Has events that can be subscribed to if one wants to be notified when certain things happen
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarting">
            <summary>
            Event that is raised when the bus is starting BEFORE the bus adds any workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarted">
            <summary>
            Event that is raised when the bus is starting AFTER the bus hass added its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposing">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            BEFORE the bus stops its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.WorkersStopped">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event, AFTER the bus has stopped all workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposed">
            <summary>
            Event that is raised when the bus is disposed AFTER the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input queue address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Defers the message delivery into the future, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.Message,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.TransportMessage,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Compression.DataCompressionMode">
            <summary>
            Enumerates strategies for when the data bus storage decorator GZIps the data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Always">
            <summary>
            Always compresses data. Please note that this requires that data can be kept in memory as this
            is required by the streaming APIs used when compressing data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Explicit">
            <summary>
            Compresses data when the <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> key is detected among the metadata
            of the save data and the value is "gzip"
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.UseCompression(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Compression.DataCompressionMode)">
            <summary>
            Enables GZIP of the saved data bus data. Set <paramref name="dataCompressionMode"/> to control when data is gzipped - if <see cref="F:Rebus.Compression.DataCompressionMode.Always"/>
            is selected the data will always be GZIPped, whereas selecting <see cref="F:Rebus.Compression.DataCompressionMode.Explicit"/> makes the data be GZIPped
            only when <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> = "gzip" is detected among the metadata for the stored data.
            Please note that GZIPping the data requires that it can be fully contained in memory because the underlying streaming APIs do not support lazy-reading a
            GZIP stream.
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZippingDataBusStorageDecorator">
            <summary>
            Decorator for <see cref="T:Rebus.DataBus.IDataBusStorage"/> that GZIP-compresses data when it is streamed in/out
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.#ctor(Rebus.DataBus.IDataBusStorage,Rebus.Compression.DataCompressionMode)">
            <summary>
            Creates the decorator, wrapping the given <paramref name="innerDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="T:Rebus.Config.Configure">
            <summary>
            Configuration entry point - call the static <see cref="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)"/> method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one that is backed by
            your favorite IoC container) in order to start configuring a Rebus instance. If your app is hosted in Microsoft's generic host, please consider using Rebus.ServiceProvider and use the
            <code>
            services.AddRebus(
                configure => configure
                    .(...)
            );
            </code>
            way of configuring Rebus instead.
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)">
            <summary>
            Call this method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one 
            that is backed by your favorite IoC container) in order to start configuring a Rebus instance.
            If your app is hosted in Microsoft's generic host, please consider using Rebus.ServiceProvider and use the
            <code>
            services.AddRebus(
                configure => configure
                    .(...)
            );
            </code>
            way of configuring Rebus instead.
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.OneWayClient">
            <summary>
            Call this method when you're using one of the Transport(t => t.***AsOneWayClient()) transports and you don't have any <see cref="T:Rebus.Activation.IHandlerActivator"/> to register.
            </summary>
        </member>
        <member name="T:Rebus.Config.DelayedStartupConfigurationExtensions">
            <summary>
            Configuration extension that allows for delaying bus startup
            </summary>
        </member>
        <member name="M:Rebus.Config.DelayedStartupConfigurationExtensions.Create(Rebus.Config.RebusConfigurer)">
            <summary>
            Starts the bus with 0 workers, thus creating a fully functional bus, only without starting message processing.
            The returned <see cref="T:Rebus.Config.IBusStarter"/> can then be used to start the bus by calling <see cref="M:Rebus.Config.IBusStarter.Start"/>
            on it.
            </summary>
        </member>
        <member name="T:Rebus.Config.IBusStarter">
            <summary>
            Wraps a bus, which has had its message processing stopped, by setting number of workers to 0.
            When <see cref="M:Rebus.Config.IBusStarter.Start"/> is called, workers are added, and message processing will start.
            </summary>
        </member>
        <member name="M:Rebus.Config.IBusStarter.Start">
            <summary>
            Starts message processing and returns the bus instance
            </summary>
        </member>
        <member name="P:Rebus.Config.IBusStarter.Bus">
            <summary>
            Gets the bus instance wrapped in this starter. The bus can be used to send, publish, subscribe, etc.
            </summary>
        </member>
        <member name="T:Rebus.Config.OneWayClientBackdoor">
            <summary>
            Helper that gives a backdoor to the configuration <see cref="T:Rebus.Config.Options"/>, allowing for one-way client settings
            to be set.
            </summary>
        </member>
        <member name="M:Rebus.Config.OneWayClientBackdoor.ConfigureOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Uses the given <see cref="T:Rebus.Config.StandardConfigurer`1"/> of <see cref="T:Rebus.Transport.ITransport"/> to set the number of workers
            to zero (effectively disabling message processing) and installs a decorator of <see cref="T:Rebus.Bus.IBus"/> that prevents
            further modification of the number of workers (thus preventing accidentally starting workers when there's no input queue).
            </summary>
        </member>
        <member name="T:Rebus.Config.Options">
            <summary>
            Contains additional options for configuring Rebus internals
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultNumberOfWorkers">
            <summary>
            This is the default number of workers that will be started, unless <see cref="P:Rebus.Config.Options.NumberOfWorkers"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultMaxParallelism">
            <summary>
            This is the default number of concurrent asynchrounous operations allowed, unless <see cref="P:Rebus.Config.Options.MaxParallelism"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultConflictResolutionAttempts">
            <summary>
            This is the default number of conflict resolution attempts that will be made, unless <see cref="P:Rebus.Config.Options.MaxConflictResolutionAttempts"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultWorkerShutdownTimeout">
            <summary>
            This is the default timeout for workers to finish running active handlers, unless <see cref="P:Rebus.Config.Options.WorkerShutdownTimeout" /> is set to something else.
            </summary>
            <value>1 minute per default.</value>
        </member>
        <member name="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval">
            <summary>
            This is the default due timeouts poll interval which will be used unless overridde by <see cref="P:Rebus.Config.Options.DueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultTransportReceiveErrorCooldownTime">
            <summary>
            This is the default time to pause, when the transport experiences an error during receive.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.NumberOfWorkers">
            <summary>
            Configures the number of workers. If thread-based workers are used, this is the number of threads that will be created.
            This number should be less than or equal to <see cref="P:Rebus.Config.Options.MaxParallelism"/>.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxParallelism">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxConflictResolutionAttempts">
            <summary>
            Configures the maximum number of conflict resolution attempts made when invoking the conflict resolution handler of a saga.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.DueTimeoutsPollInterval">
            <summary>
            Gets/sets the poll interval when checking for due timeouts
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.WorkerShutdownTimeout">
            <summary>
            Gets/sets the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.TransportReceiveErrorCooldownTime">
            <summary>
            Gets/sets the time to pause, when the transport experiences an error during receive.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.ExternalTimeoutManagerAddressOrNull">
            <summary>
            Gets/sets the address to use if an external timeout manager is to be used
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.DefaultReturnAddressOrNull">
            <summary>
            Gets/sets the default return address to use on outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.OptionalBusName">
            <summary>
            Gets/sets the name of the bus. If this is left unset, bus instances will be named with numbers.
            </summary>
        </member>
        <member name="T:Rebus.Config.OptionsConfigurer">
            <summary>
            Allows for configuring additional options
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetNumberOfWorkers(System.Int32)">
            <summary>
            Configures the number of workers to start competing over the input queue
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetBusName(System.String)">
            <summary>
            Sets the bus name, which would otherwise default to "Rebus 1", "Rebus 2", etc. 
            depending on how many instances existed in the current process
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Events(System.Action{Rebus.Bus.BusLifetimeEvents})">
            <summary>
            Provides easy access to Rebus' internal <see cref="T:Rebus.Bus.BusLifetimeEvents"/>, enabling hooking into its lifetime events.
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetMaxParallelism(System.Int32)">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetWorkerShutdownTimeout(System.TimeSpan)">
            <summary>
            Configures the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetDueTimeoutsPollInteval(System.TimeSpan)">
            <summary>
            Configures the interval between polling the endpoint's configured <see cref="T:Rebus.Timeouts.ITimeoutManager"/> for due timeouts.
            Defaults to <see cref="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetDefaultReturnAddress(System.String)">
            <summary>
            Sets the default return address to set on outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolver of the given primary implementation of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Has``1">
            <summary>
            Gets whether a primary implementation resolver has been registered for the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given decorator of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.LogPipeline(System.Boolean)">
            <summary>
            Outputs the layout of the send and receive pipelines to the log
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusConfigurer">
            <summary>
            Basic skeleton of the fluent configuration builder. Contains a method for each aspect that can be configured
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Logging(System.Action{Rebus.Config.RebusLoggingConfigurer})">
            <summary>
            Configures how Rebus logs stuff that happens
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})">
            <summary>
            Configures how Rebus sends/receives messages by allowing for choosing which implementation of <see cref="T:Rebus.Transport.ITransport"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Errors(System.Action{Rebus.Config.StandardConfigurer{Rebus.Retry.IErrorTracker}})">
            <summary>
            Configures how Rebus tracks <see cref="T:System.Exception"/>s.
            Defaults to tracking exceptions in memory. Trasking errors in memory is easy and does not require any additional configuration,
            but it can lead to excessive retrying in competing consumer scenarios, because each node will count delivery attempts individually.
            It is recommended in most cases to configure some kind of distributed error tracker when running distributed consumers.
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.DataBus(System.Action{Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage}})">
            <summary>
            Enables the data bus and configures which implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> to use.
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Routing(System.Action{Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter}})">
            <summary>
            Configures how Rebus routes messages by allowing for choosing which implementation of <see cref="T:Rebus.Routing.IRouter"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Sagas(System.Action{Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage}})">
            <summary>
            Configures how Rebus persists saga data by allowing for choosing which implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Subscriptions(System.Action{Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage}})">
            <summary>
            Configures how Rebus persists subscriptions by allowing for choosing which implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Serialization(System.Action{Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer}})">
            <summary>
            Configures how Rebus serializes messages by allowing for choosing which implementation of <see cref="T:Rebus.Serialization.ISerializer"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Timeouts(System.Action{Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager}})">
            <summary>
            Configures how Rebus defers messages to the future by allowing for choosing which implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Options(System.Action{Rebus.Config.OptionsConfigurer})">
            <summary>
            Configures additional options about how Rebus works
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Start">
            <summary>
            Finishes the setup of the bus, using default implementations for the options that have not explicitly been set.
            The only requirement, is that you must call <see cref="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})"/> and select which transport to use - everything
            else can run with a default option. It should be noted though, that several of the defaults (e.g. in-mem persistence
            options for saga storage, subscriptions, and timeouts) are not meant for production use, and should probably be
            replaced by something that is actually persistent.
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusLoggingConfigurer">
            <summary>
            Configurer that is used to configure logging. This configurer is cheating a little bit because it will actually modify a global logger which will
            be used throughout all Rebus instances. This mechanism might change in the future
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Console(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to stdout, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.ColoredConsole(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to with different colors depending on the log level, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Trace">
            <summary>
            Configures Rebus to log its stuff to <see cref="T:System.Diagnostics.Trace"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.None">
            <summary>
            Disables logging alltogether
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Configures this Rebus instance to use the specified logger factory
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="T:Rebus.Config.StandardConfigurer`1">
            <summary>
            Configurer that can have extension methods attached to it for helping with registering an implementation or a decorator
            for the <typeparamref name="TService"/> service.
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.GetConfigurerFrom(Rebus.Config.OptionsConfigurer)">
            <summary>
            Gets a standard configurer from the given options configurer. Can be used to provide
            extensions to <see cref="T:Rebus.Config.OptionsConfigurer"/> that return a standard configurer that can then
            be used to build further
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Register(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Decorate(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.OtherService``1">
            <summary>
            Gets a typed configurer for another service. Can be useful if e.g. a configuration extension for a <see cref="T:Rebus.Transport.ITransport"/>
            wants to replace the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> because it is capable of using the transport layer to do pub/sub
            </summary>
        </member>
        <member name="T:Rebus.DataBus.ClaimCheck.AutomaticClaimCheckConfigurationExtensions">
            <summary>
            Configuration extensions for Rebus' automatic big message claim check feature.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.ClaimCheck.AutomaticClaimCheckConfigurationExtensions.SendBigMessagesAsAttachments(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.Int32)">
            <summary>
            <para>
            Configures Rebus to automatically transfer message bodies as data bus attachments, if the size of the body exceeds <paramref name="bodySizeThresholdBytes"/> bytes.
            </para>
            <para>
            This can be used in situations when you know that the message size will sometimes be too big for the transport, like e.g. when using Azure Service Bus.
            With Azure Service Bus (at least at the time of writing), the maximum message size is 256 kB, including all headers and everything.
            </para>
            <para>
            Since it can be hard to predict how large the final Azure Service Bus transport message can get, if you know that your message payloads will approach the 256 kB limit,
            it is recommended to enable automatic compression of message payloads (by calling <see cref="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)"/>).
            </para>
            <para>
            If you still fear that your message payloads will approach the limit, this feature is for you :) simply ensure that the data bus is properly configured
            (e.g. to use Azure Blob Storage to store attachments), and then call this method to enable automatic big message claim check.
            </para>
            </summary>
        </member>
        <member name="T:Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep">
            <summary>
            Outgoing step that 'dehydrates' big messages by storing the payload as a data bus attachment.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep.#ctor(Rebus.DataBus.IDataBus,System.Int32)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="M:Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Dehydrates the message, if it's too big
            </summary>
        </member>
        <member name="T:Rebus.DataBus.ClaimCheck.HydrateIncomingMessageStep">
            <summary>
            Incoming step that 'hydrates' big messages, if the payload was stored as a data bus attachment.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.ClaimCheck.HydrateIncomingMessageStep.#ctor(Rebus.DataBus.IDataBus)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="M:Rebus.DataBus.ClaimCheck.HydrateIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Hydrates the message, if it was dehydrated
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusAttachment">
            <summary>
            Model that represents a data bus attachment. Only the <see cref="P:Rebus.DataBus.DataBusAttachment.Id"/> is significant, as all the
            other pieces of information are not required in order to retrieve the attachment from the database.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.#ctor(System.String)">
            <summary>
            Creates a data bus attachment with the given ID
            </summary>
        </member>
        <member name="P:Rebus.DataBus.DataBusAttachment.Id">
            <summary>
            Gets the ID of the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata(System.String)">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusStorageQuery">
            <summary>
            Helper method for data bus stuff
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusStorageQuery.IsSatisfied(System.Collections.Generic.Dictionary{System.String,System.String},Rebus.DataBus.TimeRange,Rebus.DataBus.TimeRange)">
            <summary>
            Gets whether the given data bus attachment metadata satisfies the criteria
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions">
            <summary>
            Provides extensions methods for configuring the file system storage for the data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions.StoreInFileSystem(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String)">
            <summary>
            Configures the data bus to store data in the file system
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that stores data in the file system. Could be a directory on a network share.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Time.IRebusTime)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Initialize">
            <summary>
            Initializes the file system data storage by ensuring that the configured data directory path exists and that it is writable
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given strea under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Read(System.String)">
            <summary>
            Reads the data with the given ID and returns it as a stream
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Delete(System.String)">
            <summary>
            Deletes the attachment with the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Query(Rebus.DataBus.TimeRange,Rebus.DataBus.TimeRange)">
            <summary>
            Iterates through IDs of attachments that match the given <paramref name="readTime"/> and <paramref name="saveTime"/> criteria.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBus">
            <summary>
            API for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.CreateAttachment(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates an attachment from the given source stream, optionally providing some extra metadata to be stored along with the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the currently configured data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.GetMetadata(System.String)">
            <summary>
            Uses the currently configured data bus to retrieve the metadata for the attachment with the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.Delete(System.String)">
            <summary>
            Deletes the attachment with the given ID. Throws a <see cref="T:System.NotSupportedException"/>, if the underlying data bus storage does
            not provide this functionality.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.Query(Rebus.DataBus.TimeRange,Rebus.DataBus.TimeRange)">
            <summary>
            Iterates the attachments store and returns IDs of all attachments matching the given criteria
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBusStorage">
            <summary>
            Abstraction over the data bus storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBusStorageManagement">
            <summary>
            Additional service which may/may not be provided by implementors of <see cref="T:Rebus.DataBus.IDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorageManagement.Delete(System.String)">
            <summary>
            Deletes the attachment with the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorageManagement.Query(Rebus.DataBus.TimeRange,Rebus.DataBus.TimeRange)">
            <summary>
            Iterates through IDs of attachments that match the given <paramref name="readTime"/> and <paramref name="saveTime"/> criteria.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataBusExtensions">
            <summary>
            Configuration extensions for the in-mem data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Configures the data bus to store data in memory. This is probably only useful for test scenarios, as the
            passed-in <paramref name="inMemDataStore"/> needs to be shared among endpoints on the data bus.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataStore">
            <summary>
            In-mem implementation of a data store that can be shared among buses that use the in-mem data bus.
            A shared instance of this class should be passed to all endpoints when calling <see cref="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)"/>
            </summary>
        </member>
        <member name="P:Rebus.DataBus.InMem.InMemDataStore.SizeBytes">
            <summary>
            Gets the total size in bytes 
            </summary>
        </member>
        <member name="P:Rebus.DataBus.InMem.InMemDataStore.AttachmentIds">
            <summary>
            Gets all IDs for which data is stored.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Save(System.String,System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the given bytes under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Contains(System.String)">
            <summary>
            Determines whether there is some data with the given ID.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Load(System.String)">
            <summary>
            Loads the bytes with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.AddMetadata(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Adds the metadata from the <paramref name="metadata"/> dictionary to the blob with the given <paramref name="id"/>
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.LoadMetadata(System.String)">
            <summary>
            Loads the metadata for the data with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Delete(System.String)">
            <summary>
            Deletes the data stored under the given ID and returns true when some has been deleted. 
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Reset">
            <summary>
            Resets the data store (i.e. all stored data and metadata is deleted)
            </summary>
        </member>
        <member name="T:Rebus.DataBus.MetadataKeys">
            <summary>
            Contains keys of standard metadata which is always available on data stored with the data bus
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.Length">
            <summary>
            Metadata key of the length in bytes of the stored data
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.SaveTime">
            <summary>
            Metadata key of the ISO8601-encoded time of when the data was stored
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ReadTime">
            <summary>
            Metadata key of the ISO8601-encoding time of when the data was last read
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncoding">
            <summary>
            Optional header that might contain an encoding of the contents, e.g."gzip" for gzipped data.
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncryption">
            <summary>
            Optional header that might contain the name of which encryption type was used to encode the contents, e.g."aes" for AES encrypted data.
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentInitializationVector">
            <summary>
            Optional header that contains the salt used when encrypting the data.
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncryptionKeyId">
            <summary>
            Optional header that indicates which key was used to encrypt the data.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.TimeRange">
            <summary>
            Represents a time range criterion
            </summary>
        </member>
        <member name="P:Rebus.DataBus.TimeRange.From">
            <summary>
            Gets the lower timestamp
            </summary>
        </member>
        <member name="P:Rebus.DataBus.TimeRange.To">
            <summary>
            Gets the upper timestamp
            </summary>
        </member>
        <member name="M:Rebus.DataBus.TimeRange.#ctor(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset})">
            <summary>
            Creates the criterion. Both arguments are optional
            </summary>
        </member>
        <member name="M:Rebus.DataBus.TimeRange.ToString">
            <summary>
            Renders the time range
            </summary>
        </member>
        <member name="T:Rebus.Encryption.AesEncryptor">
            <summary>
            Helps with encrypting/decrypting byte arrays, using the <see cref="T:System.Security.Cryptography.Aes"/> algorithm
            </summary>
        </member>
        <member name="P:Rebus.Encryption.AesEncryptor.ContentEncryptionValue">
            <summary>
            Returns "aes" string
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.#ctor(System.String)">
            <summary>
            Creates the encryptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.#ctor(Rebus.Encryption.IEncryptionKeyProvider)">
            <summary>
            Creates the encryptor with an <see cref="T:Rebus.Encryption.IEncryptionKeyProvider"/> which provides current encryption key and lookup for keys based on id
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DecryptMessagesIncomingStep">
            <summary>
            Incoming message step that checks for the prensence of the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header, decrypting
            the message body if it is present.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.#ctor(Rebus.Encryption.IAsyncEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Decrypts the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DefaultAsyncEncryptor">
            <summary>
            Default implementation of <see cref="T:Rebus.Encryption.IAsyncEncryptor"/> which wraps an instance of <see cref="T:Rebus.Encryption.IEncryptor"/>.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DefaultAsyncEncryptor.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Creates the encryptor wrapping an <see cref="T:Rebus.Encryption.IEncryptor"/>
            </summary>
        </member>
        <member name="P:Rebus.Encryption.DefaultAsyncEncryptor.ContentEncryptionValue">
            <inheritdoc cref="P:Rebus.Encryption.IEncryptor.ContentEncryptionValue"/>
        </member>
        <member name="M:Rebus.Encryption.DefaultAsyncEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <inheritdoc cref="M:Rebus.Encryption.IEncryptor.Decrypt(Rebus.Encryption.EncryptedData)"/>
        </member>
        <member name="M:Rebus.Encryption.DefaultAsyncEncryptor.Encrypt(System.Byte[])">
            <inheritdoc cref="M:Rebus.Encryption.IEncryptor.Encrypt(System.Byte[])"/>
        </member>
        <member name="T:Rebus.Encryption.EncryptedData">
            <summary>
            Represents a chunk of encrypted data along with the salt (a.k.a. "Initialization Vector"/"IV") that was used to encrypt it.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructs an instance from the given bytes and iv.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[],System.String)">
            <summary>
            Constructs an instance from the given bytes, iv and optional key id.
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Iv">
            <summary>
            Gets the salt (a.k.a. "Initialization Vector"/"IV") from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Bytes">
            <summary>
            Gets the raw data from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.KeyId">
            <summary>
            Gets the identifier of the key used to encrypt this data instance
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptingDataBusStorageDecorator">
            <summary>
            Decorator of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that encrypts/decrypts data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptingDataBusStorageDecorator.#ctor(Rebus.DataBus.IDataBusStorage,Rebus.Encryption.IAsyncEncryptor)">
            <summary>
            Creates the decorator
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptingDataBusStorageDecorator.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Encryption.EncryptingDataBusStorageDecorator.Read(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Encryption.EncryptingDataBusStorageDecorator.ReadMetadata(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Rebus.Encryption.EncryptionConfigurationExtensions">
            <summary>
            Configuration extensions for enabling encrypted message bodies
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages. 
            Uses the default "Rijndael" algorithm which is 256 bit AES encryption.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomEncryption(Rebus.Config.OptionsConfigurer)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages using custom encryption provider.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            Custom encrypotion providers are configured by building on the returned configurer, e.g. like so:
            <code>
            Configure.With(...)
                .(...)
                .Options(o => {
                    o.EnableCustomEncryption()
                        .Register(c => new MyCustomEncryptor());
                })
                .Start();
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomAsyncEncryption(Rebus.Config.OptionsConfigurer)">
            <inheritdoc cref="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomEncryption(Rebus.Config.OptionsConfigurer)" />
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage})">
            <summary>
            Enables encryption
            </summary>
            <param name="configurer"></param>
            <exception cref="T:Rebus.Exceptions.RebusConfigurationException"></exception>
        </member>
        <member name="T:Rebus.Encryption.EncryptionHeaders">
            <summary>
            Special headers that are used when the message contents are encrypted
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption">
            <summary>
            Optional header element that specifies an encryption algorithm that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.KeyId">
            <summary>
            Optional header element that specifies the key that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentInitializationVector">
            <summary>
            When the contents have been encrypted, this header has the IV
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.DisableEncryptionHeader">
            <summary>
            Special header that can be added to a message in order to disable encryption for that particular message
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionKey">
            <summary>
            Container of an encryptionkey and its identifier.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionKey.#ctor(System.Byte[],System.String)">
            <summary>
            A new encryptionkey with key content and identifier.
            </summary>
            <param name="key">Encryptionkey as byte array.</param>
            <param name="identifier">Identifier for provided key.</param>
        </member>
        <member name="P:Rebus.Encryption.EncryptionKey.Key">
            <summary>
            Key as byte array
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptionKey.Identifier">
            <summary>
            Identifier for this key.
            Typically used for describing which key that was used for encrypting, and must be used for decrypting.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptMessagesOutgoingStep">
            <summary>
            Outgoing pipeline step that encrypts the contents of the outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.#ctor(Rebus.Encryption.IAsyncEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Encrypts the outgoing <see cref="T:Rebus.Messages.TransportMessage"/> and adds appropriate headers
            </summary>
        </member>
        <member name="T:Rebus.Encryption.FixedAesEncryptionKeyProvider">
            <summary>
            Helps with providing encryption keys for encrypting and decrypting messages.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedAesEncryptionKeyProvider.#ctor(System.String)">
            <summary>
            Creates the keyprovider with the specified key - the key must be a valid, base64-encoded key.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedAesEncryptionKeyProvider.GenerateNewKey(System.Int32)">
            <summary>
            Generates a new, random key which may be used to initialize this <see cref="T:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedAesEncryptionKeyProvider.GetCurrentKey">
            <summary>
            Returns the key the provider was constructed with.
            </summary>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="M:Rebus.Encryption.FixedAesEncryptionKeyProvider.GetSpecificKey(System.String)">
            <summary>
            Returns a key matching the <paramref name="identifier"/> if found.
            </summary>
            <param name="identifier">Identifier describing which key caller is asking for.</param>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="T:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider">
            <summary>
            Helps with providing encryption keys for encrypting and decrypting messages when the key is fixed.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider.#ctor(System.String)">
            <summary>
            Creates the keyprovider with the specified key - the key must be a valid, base64-encoded key.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider.GenerateNewKey">
            <summary>
            Generates a new, random key which may be used to initialize this <see cref="T:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider.GetCurrentKey">
            <summary>
            Returns the key the provider was constructed with.
            </summary>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="M:Rebus.Encryption.FixedRijndaelEncryptionKeyProvider.GetSpecificKey(System.String)">
            <summary>
            Returns a key matching the <paramref name="identifier"/> if found.
            </summary>
            <param name="identifier">Identifier describing which key caller is asking for.</param>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="T:Rebus.Encryption.IAsyncEncryptor">
            <summary>
            Interface to provide async encryption/decryption custom implementation
            </summary>
        </member>
        <member name="P:Rebus.Encryption.IAsyncEncryptor.ContentEncryptionValue">
            <summary>
            Header name that will be added to an encrypted message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IAsyncEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the encrypted data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IAsyncEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given bytes and returns the encrypted data along with the salt in the returned <see cref="T:Rebus.Encryption.EncryptedData"/>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.IEncryptionKeyProvider">
            <summary>
            Describes a provider capable of returning keys used for encrypting and decrypting messages 
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptionKeyProvider.GetCurrentKey">
            <summary>
            Returns the default key that should be used for encryption 
            </summary>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="M:Rebus.Encryption.IEncryptionKeyProvider.GetSpecificKey(System.String)">
            <summary>
            Returns an <see cref="T:Rebus.Encryption.EncryptionKey"/> if the provider is capable finding one matching the <paramref name="identifier"/>. 
            </summary>
            <param name="identifier">The identifier unique for this key</param>
            <returns>An<see cref="T:Rebus.Encryption.EncryptionKey"/> containing the key and its identifier</returns>
        </member>
        <member name="T:Rebus.Encryption.IEncryptor">
            <summary>
            Interface to provide encryption/decryption custom implementation
            </summary>
        </member>
        <member name="P:Rebus.Encryption.IEncryptor.ContentEncryptionValue">
            <summary>
            Header name that will be added to an encrypted message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the encrypted data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given bytes and returns the encrypted data along with the salt in the returned <see cref="T:Rebus.Encryption.EncryptedData"/>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.RijndaelEncryptor">
            <summary>
            Helps with encrypting/decrypting byte arrays, using the <see cref="T:System.Security.Cryptography.RijndaelManaged"/> algorithm (which is actually AES with 256 bits key size)
            </summary>
        </member>
        <member name="P:Rebus.Encryption.RijndaelEncryptor.ContentEncryptionValue">
            <summary>
            Returns "rijndael" string
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.#ctor(System.String)">
            <summary>
            Creates the encryptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.#ctor(Rebus.Encryption.IEncryptionKeyProvider)">
            <summary>
            Creates the encryptor with an <see cref="T:Rebus.Encryption.IEncryptionKeyProvider"/> which provides current encryption key and lookup for keys based on id
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.ConcurrencyException">
            <summary>
            Special exception that signals that some kind of optimistic lock has been violated, and work must most likely be aborted &amp; retried
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.FailFastException">
            <summary>
            Fail-fast exception bypasses the retry logic and goes to the error queue directly
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.IFailFastException">
            <summary>
            Marker interface for exceptions for which Rebus should not bother to retry delivery
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException">
            <summary>
            Fail-fast exception bypasses the retry logic and goes to the error queue directly
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusApplicationException">
            <summary>
            Generic application exception to use when something bad happens that is pretty unexpected and should be taken seriously
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusConfigurationException">
            <summary>
            Generic configuration exception to use instead of ConfigurationErrorsException from System.Configuration
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.TransportMessageApiExtensions">
            <summary>
            Extensions for <see cref="T:Rebus.Bus.Advanced.ITransportMessageApi"/>
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.TransportMessageApiExtensions.Deadletter(Rebus.Bus.Advanced.ITransportMessageApi,System.String,System.Boolean)">
            <summary>
            Manually dead-letters the message currently being handled. Optionally passes the given <paramref name="errorDetails"/> along as the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header.
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.TransportMessageApiExtensions.Deadletter(Rebus.Bus.Advanced.ITransportMessageApi,System.Exception,System.Boolean)">
            <summary>
            Manually dead-letters the message currently being handled. Optionally passes the given <paramref name="exception"/> along as the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header.
            </summary>
        </member>
        <member name="T:Rebus.ExclusiveLocks.ConcurrentDictionaryExclusiveAccessLock">
            <summary>
            ConcurrentDictionary implementation of <see cref="T:Rebus.ExclusiveLocks.IExclusiveAccessLock"/>
            </summary>
        </member>
        <member name="T:Rebus.ExclusiveLocks.IExclusiveAccessLock">
            <summary>
            Defines API for generic exclusive locks
            </summary>
        </member>
        <member name="M:Rebus.ExclusiveLocks.IExclusiveAccessLock.AcquireLockAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Acquire a lock for given key
            </summary>
            <param name="key">Locking key</param>
            <param name="cancellationToken">Cancellation token which will be cancelled if Rebus shuts down. Can be used if e.g. distributed locks have a timeout associated with them</param>
            <returns>True if the lock was acquired, false if not</returns>
        </member>
        <member name="M:Rebus.ExclusiveLocks.IExclusiveAccessLock.IsLockAcquiredAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Determines if a lock has been acquired or not
            </summary>
            <param name="key">Locking key</param>
            <param name="cancellationToken">Cancellation token which will be cancelled if Rebus shuts down. Can be used if e.g. distributed locks have a timeout associated with them</param>
            <returns>True of the lock was acquired already, false if not</returns>
        </member>
        <member name="M:Rebus.ExclusiveLocks.IExclusiveAccessLock.ReleaseLockAsync(System.String)">
            <summary>
            Release a lock for given key
            </summary>
            <param name="key">Locking key</param>
            <returns>True of the lock was released, false if not</returns>
        </member>
        <member name="T:Rebus.Extensions.DateTimeExtensions">
            <summary>
            Defines a few nice extensions for making working with <see cref="T:System.DateTimeOffset"/> more nice
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ElapsedUntilNow(System.DateTimeOffset,Rebus.Time.IRebusTime)">
            <summary>
            Gets the time from this instant until now (as returned by <see cref="P:Rebus.Time.IRebusTime.Now"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToIso8601DateTimeOffset(System.DateTimeOffset)">
            <summary>
            Serializes this instant with the "O" format, i.e. ISO8601-compliant
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToDateTimeOffset(System.String)">
            <summary>
            Parses an ISO8601-compliant string into a proper <see cref="T:System.DateTimeOffset"/>
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DictionaryExtensions">
            <summary>
            Provides some nifty extensions to <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.MergedWith``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a new dictionary that contains all key-value pairs from both dictionaries. If the same key is present the value from <paramref name="otherDictionary"/> takes precedence
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.Clone(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a new dictionary with the same key-value pairs as the target
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValue(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, throwing a MUCH nicer <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValueOrNull(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, returning null if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})">
            <summary>
            Provides a function similar to <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>, only
            on <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAddAsync``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Provides a function similar to <see cref="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})"/>, only where the factory function can be async
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Maps the given sequence of items to key-value pairs, returning them in a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrThrow``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrNull``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="T:Rebus.Extensions.MessageContextExtensions">
            <summary>
            Convenient extensions for working with the message context
            </summary>
        </member>
        <member name="M:Rebus.Extensions.MessageContextExtensions.GetCancellationToken(Rebus.Pipeline.IMessageContext)">
            <summary>
            Gets the bus' shutdown <see cref="T:System.Threading.CancellationToken"/>. Can be used when implementing long-running
            message handlers to avoid blocking bus shutdown, either by periodically checking <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>
            or calling <see cref="M:System.Threading.CancellationToken.ThrowIfCancellationRequested"/>, or by passing it to asynchronous operations that support
            the cancellation pattern.
            </summary>
        </member>
        <member name="T:Rebus.Extensions.TypeExtensions">
            <summary>
            Provides extensions of <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the type's base types (i.e. the <see cref="T:System.Type"/> for each implemented interface and for each class inherited from, all the way up to <see cref="T:System.Object"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
            Gets the assembly-qualified name of the type, without any version info etc.
            E.g. "System.String, mscorlib"
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages">
            <summary>
            Base message handler interface. Don't implement this one directly, it would give you nothing
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages`1">
            <summary>
            Message handler interface. Implement this in order to get to handle messages of a specific type
            </summary>
        </member>
        <member name="M:Rebus.Handlers.IHandleMessages`1.Handle(`0)">
            <summary>
            This method will be invoked with a message of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Handlers.InternalHandlersContributor">
            <summary>
            Decoration of <see cref="T:Rebus.Activation.IHandlerActivator"/> that adds a few special handlers when an incoming message can be recognized
            as a special Rebus message
            </summary>
        </member>
        <member name="M:Rebus.Handlers.InternalHandlersContributor.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Gets Rebus' own internal handlers (if any) for the given message type
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> that allows for specifying additional handler types
            whose order to fix
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1">
            <summary>
            Specifies the handler that will be put next in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            again to specify the next handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions">
            <summary>
            Configuration extensions for setting up an order of handlers that must be respected when
            two or more of the handlers are present in the same handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)">
            <summary>
            Initiates the configuration of the handler ordering - call <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> in
            order to specify the handler that will be put first in the pipeline if it is present
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingStep">
            <summary>
            Incoming message step that can reorder handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.#ctor(Rebus.Handlers.Reordering.ReorderingConfiguration)">
            <summary>
            Constructs the step with the given configuration
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Reorders the handler invokers if necessary
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.ReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)"/> that can be used as a
            fluent syntax to specify the desired order of the handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1">
            <summary>
            Specifies the handler that will be put first in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            any number of times to specify the next handler
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.GetIndex(System.Object)">
            <summary>
            Gets the sorting index for the given handler
            </summary>
        </member>
        <member name="T:Rebus.Injection.Injectionist">
            <summary>
            Dependency injectionist that can be used for configuring a system of injected service implementations, possibly with decorators,
            with caching of instances so that the same instance of each class is used throughout the tree. Should probably not be used for
            anything at runtime, is only meant to be used in configuration scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Get``1">
            <summary>
            Starts a new resolution context, resolving an instance of the given <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="E:Rebus.Injection.Injectionist.ResolveRequested">
            <summary>
            Events that is raised when the resolution of a top-level instance is requested
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide an instance of <typeparamref name="TService"/>. Optionally,
            the supplied <paramref name="description"/> will be used to report more comprehensible errors in case of
            conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a decorator factory method that can provide an instance of <typeparamref name="TService"/> 
            (i.e. the resolver is expected to call <see cref="M:Rebus.Injection.IResolutionContext.Get``1"/> where TService
            is <typeparamref name="TService"/>. Optionally, the supplied <paramref name="description"/> will be used 
            to report more comprehensible errors in case of conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Has``1(System.Boolean)">
            <summary>
            Returns whether there exists a registration for the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="T:Rebus.Injection.IResolutionContext">
            <summary>
            Represents the context of resolving one root service and can be used throughout the tree to fetch something to be injected
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Get``1">
            <summary>
            Gets an instance of the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="P:Rebus.Injection.IResolutionContext.TrackedInstances">
            <summary>
            Gets all instances resolved within this resolution context at this time.
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Has``1(System.Boolean)">
            <summary>
            Gets whether there exists a primary registration for the <typeparamref name="TService"/> type
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionException">
            <summary>
            Exceptions that is thrown when something goes wrong while working with the injectionist
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionResult`1">
            <summary>
            Contains a built object instance along with all the objects that were used to build the instance
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.Instance">
            <summary>
            Gets the instance that was built
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.TrackedInstances">
            <summary>
            Gets all object instances that were used to build <see cref="P:Rebus.Injection.ResolutionResult`1.Instance"/>, including the instance itself
            </summary>
        </member>
        <member name="T:Rebus.Internals.Shims">
            <summary>
            Internal shims - compiler hints on the form #if NETSTANDARD1_3 etc should be moved here
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)">
            <summary>
            Must get a logger instance for the given <paramref name="type"/>
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.RenderString(System.String,System.Object[])">
            <summary>
            Renders the <paramref name="message"/> string by replacing placeholders on the form <code>{whatever}</code> with the
            string representation of each object from <paramref name="objs"/>. Note that the actual content of the placeholders
            is ignored - i.e. it doesn't matter whether it says <code>{0}</code>, <code>{name}</code>, or <code>{whatvgejigoejigoejigoe}</code>
            - values are interpolated based on their order regardless of the name of the placeholder.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.FormatObject(System.Object,System.String)">
            <summary>
            Formatter function that is invoked for each object value to be rendered into a string while interpolating log lines
            </summary>
        </member>
        <member name="T:Rebus.Logging.ColorSetting">
            <summary>
            Represents a console color setting consisting of a foreground and a background color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.ForegroundColor">
            <summary>
            Gets the foreground color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.BackgroundColor">
            <summary>
            Gets the background color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Foreground(System.ConsoleColor)">
            <summary>
            Sets the foreground color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Background(System.ConsoleColor)">
            <summary>
            Sets the background color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Apply">
            <summary>
            Sets the foreground (and possibly background too) colors of the console
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Revert">
            <summary>
            Resets the console colors to their normal values
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory">
            <summary>
            Logger factory that logs stuff to the console
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory.LogStatement">
            <summary>
            One single log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Level">
            <summary>
            The level of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Text">
            <summary>
            The text (possibly inclusing formatting placeholders) of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Args">
            <summary>
            The values to use for string interpolation
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Type">
            <summary>
            The type to which this particular logger belongs
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the logger factory
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Colors">
            <summary>
            Gets or sets the colors to use when logging
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.MinLevel">
            <summary>
            Gets or sets the minimum logging level to output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Filters">
            <summary>
            Gets the list of filters that each log statement will be passed through in order to evaluate whether
            the given log statement should be output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.ShowTimestamps">
            <summary>
            Gets/sets whether timestamps should be shown when logging
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a logger for logging stuff from within the specified type
            </summary>
        </member>
        <member name="T:Rebus.Logging.ILog">
            <summary>
            Interface of a Rebus logger
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes the specified message with the DEBUG level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes the specified message with the INFO level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. You can make a tiny shortcut by deriving from <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> if you intend to implement this interface
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Rebus.Logging.LoggingColors">
            <summary>
            Represents a set of colors to be used by the <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> when running
            in colored mode
            </summary>
        </member>
        <member name="M:Rebus.Logging.LoggingColors.#ctor">
            <summary>
            Constructs the default set of logging colors, which if gray, green, yellow, and red foreground for log
            levels debug, info, warn, and error respectively.
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Debug">
            <summary>
            Gets/sets the color to use when printing DEBUG log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Info">
            <summary>
            Gets/sets the color to use when printing INFO log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Warn">
            <summary>
            Gets/sets the color to use when printing WARN log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Error">
            <summary>
            Gets/sets the color to use when printing ERROR log statements
            </summary>
        </member>
        <member name="T:Rebus.Logging.LogLevel">
            <summary>
            Enumeration of the log levels available with Rebus loggers. As a general rule of thumb, levels WARN
            and ERROR should, as a minimum, ALWAYS be logged to a local file or another persistent means.
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Debug">
            <summary>
            Log statement of very low importance which is most likely only relevant in extreme debugging scenarios
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Info">
            <summary>
            Log statement of low importance to unwatched running systems which however can be very relevant when testing and debugging
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Warn">
            <summary>
            Log statement of fairly high importance - always contains relevant information on somewhing that may be a sign that something is wrong
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Error">
            <summary>
            Log statement of the highest importance - always contains relevant information on something that has gone wrong
            </summary>
        </member>
        <member name="T:Rebus.Logging.NullLoggerFactory">
            <summary>
            This is the /dev/null of loggers...
            </summary>
        </member>
        <member name="M:Rebus.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Returns a <see cref="T:Rebus.Logging.NullLoggerFactory.NullLogger"/> which is the /dev/null of logging...
            </summary>
        </member>
        <member name="T:Rebus.Logging.TraceLoggerFactory">
            <summary>
            Logger factory that writes log statements using the <see cref="T:System.Diagnostics.Trace"/> API
            </summary>
        </member>
        <member name="M:Rebus.Logging.TraceLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.TraceLoggerFactory.TraceLogger"/>
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.SubscribeRequest">
            <summary>
            Control message that can be used to establish a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to enlist for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.Topic">
            <summary>
            Specifis the topic for which the subscriber wishes to subscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.UnsubscribeRequest">
            <summary>
            Control message that can be used to end a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to remove for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.Topic">
            <summary>
            Specifis the topic from which the subscriber wishes to unsubscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.HeaderAttribute">
            <summary>
            Header attribute that can be used to automatically add some specific header to all outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Key">
            <summary>
            Gets the key of the header
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Value">
            <summary>
            Gets the value of the header
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates the header attribute with the given key and value
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String)">
            <summary>
            Creates the header attribute with the given key and an empty value
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers">
            <summary>
            Contains keys of headers known &amp; used by Rebus
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.MessageId">
            <summary>
            Id of the message. Either set the ID explicitly when sending a message, or Rebus will assign one to the message.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Type">
            <summary>
            .NET type (if possible) of the sent message 
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationId">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get the correlation ID (or the message ID
            if there's no correlation ID) of the handled message copied to it. When a message is initially sent, its correlation ID
            will be its own message ID.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.InReplyTo">
            <summary>
            Contains the <see cref="F:Rebus.Messages.Headers.MessageId"/> from the handled message when replying from a handler
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationSequence">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get a correlation sequence number of the handled message 
            incremented by 1 copied to it. When a message is initially sent, its correlation sequence number is 0. The sequence number
            can be used to deduce a strict ordering of correlated messages, even in the face of clock skew among servers
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ReturnAddress">
            <summary>
            The return address of the message, i.e. the address that repliers must reply to.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SenderAddress">
            <summary>
            Address of the message sender, if the sender is not a one-way client.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.RoutingSlipItinerary">
            <summary>
            A ;-separated list of addresses that the routing slip must visit
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.RoutingSlipTravelogue">
            <summary>
            A ;-separated list of addresses that the routing slip has visited
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentType">
            <summary>
            Describes the contents of the message with a type and an encoding
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentEncoding">
            <summary>
            Optional header element that specifies an encoding that the content is encoded with, e.g. gzip
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ErrorDetails">
            <summary>
            Details that can be attached to a message that is forwarded after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SourceQueue">
            <summary>
            Source queue of a message the has bee forwarded to an error queue after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredUntil">
            <summary>
            Indicates that the message must not be consumed right away, delivery should be delayed until the specified time
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredRecipient">
            <summary>
            Indicates to which input queue the deferred message must be delivered back to
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferCount">
            <summary>
            Indicates how many times the message has been deferred. Will initially be set to 1, and will then be incremented each time the transport message
            is deferred with <see cref="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.TimeToBeReceived">
            <summary>
            Indicates a time span (as a string, on the form hh:MM:ss) after which the queueing system can safely delete the message and thus never deliver it
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Express">
            <summary>
            Header that indicates that the queueing system can trade reliability for performance in order to deliver this message as fast as possible
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SentTime">
            <summary>
            Headers with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message was sent.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Intent">
            <summary>
            Header that indicates whether this message was sent or published
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers.IntentOptions">
            <summary>
            Contains the possible values for the <see cref="F:Rebus.Messages.Headers.Intent"/> header
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PointToPoint">
            <summary>
            This value indicates that the message was sent to one specific recipient, i.e. either by sending or replying
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe">
            <summary>
            This value indicates that the message was published to zero or more recipients, i.e. it might not actually be received by anyone.
            When auditing is enabled, a copy is always stored of published messages, regardless of the number of recipients.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.MessagePayloadAttachmentId">
            <summary>
            Header that contains the ID of a data bus attachment, which was used to store the message body
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeliveryCount">
            <summary>
            Optional header that can be provided on incoming messages by transports that have native support for counting attempted deliveries.
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Logical message wrapper that has a set of headers and a .NET object
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Object)">
            <summary>
            Constructs the message with the specified headers, wrapping the given .NET object as the message body
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Body">
            <summary>
            Gets the wrapped body object of this message
            </summary>
        </member>
        <member name="T:Rebus.Messages.OriginalTransportMessage">
            <summary>
            Wraps the originally received transport message while processing the message because the original 
            instance might be replaced during the processing (e.g. when its body is changed during decompression/decryption etc.)
            This instance must not be changed
            </summary>
        </member>
        <member name="P:Rebus.Messages.OriginalTransportMessage.TransportMessage">
            <summary>
            Gets the originally received transport message
            </summary>
        </member>
        <member name="M:Rebus.Messages.OriginalTransportMessage.#ctor(Rebus.Messages.TransportMessage)">
            <summary>
            Creates the wrapper
            </summary>
        </member>
        <member name="T:Rebus.Messages.TransportMessage">
            <summary>
            Transport message wrapper that has a set of headers and a stream of raw data to be sent/received
            </summary>
        </member>
        <member name="M:Rebus.Messages.TransportMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Constructs the transport message with the given headers, wrapping the given body payload
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Body">
            <summary>
            Gets the wrapped body data of this message
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemHelpers.EnsureDirectoryIsWritable(System.String)">
            <summary>
            Make sure the directory is writeable by the current process
            </summary>
            <param name="directoryPath">Directory path to check</param>
            <exception cref="T:System.IO.IOException">Exception thrown if directory cannot be written to</exception>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that writes saga data snapshots as JSON text to a directory in the file system
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage which will write saga data snapshots to files using file names on the form "ID-REVISION.json"
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Initialize">
            <summary>
            Initializes the file system-based saga snapshot storage by ensuring that the snapshot directory exists and
            making sure that it's writable
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions">
            <summary>
            Configuration extensions for the <see cref="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String)">
            <summary>
            Configures Rebus to use JSON files to store snapshots of saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that uses the file system to store data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the saga storage using the given <paramref name="basePath"/> 
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data instance from the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data instance into the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given saga data instance in the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Removes the saga data instance from the index file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions">
            <summary>
            Configures extensions for using the filesystem to store sagas
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions.UseFilesystem(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String)">
            <summary>
            Configures Rebus to use the filesystem to store sagas. Please note that this way of storing saga data is not
            the most effective, and therefore it is probably best suited for testing and very simple and mild requirements
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that stores timeouts in the filesystem
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Time.IRebusTime)">
            <summary>
            Creates the timeout manager, storing timeouts in the given <paramref name="basePath"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message to be retrieved later
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.GetDueMessages">
            <summary>
            Gets all messages that are due at this instant
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemTimeoutStorageConfigurationExtensions">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutStorageConfigurationExtensions.UseFileSystem(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String)">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
            <param name="configurer">the rebus configuration</param>
            <param name="basePath">the path to store timeouts under</param>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that stores subscriptions in a JSON file. Access to the file is synchronized within the process with a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all subscribers of the given topic from the JSON file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber to the list of subscribers from the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber from the list of subscribers of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized (which it shouldn't be - that would probably cause some pretty nasty locking exceptions!)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.ReaderWriterLockSlim"/> that guards access to the file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions">
            <summary>
            Configurations extensions for configuring Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String)">
            <summary>
            Configures Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that "persists" saga data in memory. Saga data is serialized/deserialized using Newtonsoft JSON.NET
            with some pretty robust settings, so inheritance and interfaces etc. can be used in the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySagaStorage.Instances">
            <summary>
            Returns all stored saga data instances. 
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data of the given type with a property of the specified name and the specified value
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Saves the given saga data, throwing an exception if the instance already exists
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the saga data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Reset">
            <summary>
            Resets the saga storage (i.e. all stored saga data instances are deleted)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorageExtensions">
            <summary>
            Configuration extensions for in-mem saga storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage})">
            <summary>
            Configures Rebus to store sagas in memory. Please note that while this method can be used for production purposes
            (if you need a saga storage that is pretty fast), it is probably better to use a persistent storage (like SQL Server
            or another database), because the state of all sagas will be lost in case the endpoint is restarted.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriberStore">
            <summary>
            In-mem subscriber store that can be shared among multiple endpoints to emulate a shared subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySubscriberStore.Topics">
            <summary>
            Gets all topics which are known by the subscriber store. 
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.GetSubscribers(System.String)">
            <summary>
            Gets the subscribers for the current topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.AddSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber with the given <paramref name="subscriberAddress"/> to the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.RemoveSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber with the given <paramref name="subscriberAddress"/> from the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.Reset">
            <summary>
            Resets the subscriber store (i.e. all known topics and their subscriptions are deleted)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that "persists" subscriptions in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor">
            <summary>
            Creates the in-mem subscription storage as a decentralized subscription storage with its
            own private subscriber store
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor(Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Creates the in-mem subscription storage as a centralized subscription storage, using the given
            <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> to share subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions">
            <summary>
            Configuration extensions for in-mem subscriptionstorage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be CENTRALIZED
            with this overload because a <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in.  PLEASE NOTE that this 
            is probably not useful for any other scenario  than TESTING because usually you want subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage})">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be DECENTRALIZED
            with this overload because NO <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in and subscriptions are therefore private
            for this endpoint.  PLEASE NOTE that this  is probably not useful for any other scenario  than TESTING because usually you want 
            subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that "persists" timeouts in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.#ctor(Rebus.Time.IRebusTime)">
            <summary>
            Creates the in-mem timeout manager
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage">
            <summary>
            Represents a message whose delivery has been deferred into the future
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.DueTime">
            <summary>
            Gets the time of when delivery of this message is due
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Headers">
            <summary>
            Gets the message's headers
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Body">
            <summary>
            Gets the message's body
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetEnumerator">
            <summary>
            Gets an enumerator that allows for iterating through all stored deferred messages
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManagerExtensions">
            <summary>
            Configuration extensions for in-mem timeout manager
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManagerExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager})">
            <summary>
            Configures Rebus to store timeouts in memory. Please note that this is probably not really suitable for production usage,
            as deferred messages will be lost in case the endpoint is restarted. Therefore, the in-mem timeout manager is probably
            mostly suited best to be used in automated tests.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipeline">
            <summary>
            Default pipeline implementation that can be built with a fluent syntax by calling <see cref="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)"/> and <see cref="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)"/> respectively,
            in the order that the steps must be invoked in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.#ctor(System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep},System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Creates the pipeline, possibly initializing it from the given <paramref name="initialOutgoingSteps"/> and/or <paramref name="initialIncomingSteps"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.SendPipeline">
            <summary>
            Gets the send pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)">
            <summary>
            Adds a new incoming step to the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)">
            <summary>
            Adds a new outgoing step to the send pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IIncomingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each incoming message to be handled.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the incoming message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IMessageContext">
            <summary>
            Representation of the current "message context", which is a convenience wrapper that gives access to the current <see cref="T:Rebus.Transport.ITransactionContext"/>
            (which is the outermost context, the one that spans the entire queue receive transaction) and the current
            <see cref="P:Rebus.Pipeline.IMessageContext.IncomingStepContext"/> (which is actually contained in the transaction context).
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IncomingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing incoming messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IncomingStepContext.#ctor(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.TransportMessage"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.ActionPipelineInvoker">
            <summary>
            Action-based pipeline invoker that recursively composes actions to invoke the pipelines
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.DefaultPipelineInvoker">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IOutgoingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each outgoing message to be sent.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipeline">
            <summary>
            Models a pipeline of steps that will be executed for each sent/received message respectively
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.SendPipeline">
            <summary>
            Gets the send pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> implementations that will be executed for each outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> implementations that will be executed for each incoming message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipelineInvoker">
            <summary>
            The invoker is capable of invoking an ordered pipeline of steps
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IStep">
            <summary>
            General step interface - allows for treating incoming/outgoing pipeline steps equally in some regards, even though they're different
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.MessageContext">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IMessageContext"/> that provides the static gateway <see cref="P:Rebus.Pipeline.MessageContext.Current"/> property to get
            the current message context.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Current">
            <summary>
            Gets the current message context from the current <see cref="T:Rebus.Transport.AmbientTransactionContext"/> (accessed by
            <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/>), returning null if no transaction context was found
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.OutgoingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.OutgoingStepContext.#ctor(Rebus.Messages.Message,Rebus.Transport.ITransactionContext,Rebus.Pipeline.Send.DestinationAddresses)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.Message"/>, list of <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineAbsolutePosition">
            <summary>
            Indicates an absolute position in the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Front">
            <summary>
            Denotes the front of the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Back">
            <summary>
            Denotes the back of the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineMessageContextExtensions">
            <summary>
            Extensions for the message context 
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineMessageContextExtensions.AbortDispatch(Rebus.Pipeline.IMessageContext)">
            <summary>
            Aborts the current message processing pipeline by making the currently executing handler the last one.
            This means that any message handlers following the current one in the current pipeline will NOT be executed.
            If no errors occurred, the queue transaction will be committed as if everything is allright.
            This method can be used to ABORT message process to allow for a handler to FUNCTION AS A FILTER.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineRelativePosition">
            <summary>
            Indicates in which way a position is related to another step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.Before">
            <summary>
            Indicates that the step must be positioned before the other step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.After">
            <summary>
            Indicates that the step must be positioned after the other step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepConcatenator">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can concatenate steps to either pipeline at the front or at the back
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the concatenator
            </summary>
            <param name="pipeline"></param>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified outgoing <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified receive <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.SendPipeline">
            <summary>
            Gets the send pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.ReceivePipeline">
            <summary>
            Gets the receive pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepInjector">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can inject one or more steps into either pipeline,
            position in the injected steps relatively to another step by its type.
            Could probably be extended with more ways of detecting "the other step" than by its concrete type.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the step injector, wrapping the given <see cref="T:Rebus.Pipeline.IPipeline"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.SendPipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that makes up the outgoing pipeline, injecting any configured outgoing steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.ReceivePipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> that makes up the incoming pipeline, injecting any configured incoming steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IOutgoingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IIncomingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepRemover">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can remove steps based on a predicate
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the pipeline step remover, wrapping the given pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.SendPipeline">
            <summary>
            Gets the outgoing steps from the wrapped pipeline, unless those where one of the registered outgoing step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.ReceivePipeline">
            <summary>
            Gets the incoming steps from the wrapped pipeline, unless those where one of the registered incoming step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveIncomingStep(System.Func{Rebus.Pipeline.IIncomingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching incoming steps to be removed from the pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveOutgoingStep(System.Func{Rebus.Pipeline.IOutgoingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching outgoing steps to be removed from the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.ActivateHandlersStep">
            <summary>
            Incoming message step that gets relevant handlers for the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.#ctor(Rebus.Activation.IHandlerActivator)">
            <summary>
            Constructs the step with the <see cref="T:Rebus.Activation.IHandlerActivator"/> to use to get the handler instances
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Looks up handlers for the incoming message and saves the handlers (without invoking them) to the context as a <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.GetHandlerInvokers``1(``0,Rebus.Transport.ITransactionContext,Rebus.Messages.Message)">
            <summary>
            Returns an instance of <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/> containing the list of handlers that will process this message.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.CreateHandlerInvoker``1(Rebus.Handlers.IHandleMessages{``0},``0,Rebus.Transport.ITransactionContext,Rebus.Messages.Message)">
            <summary>
            Creates instance of HandlerInvoker
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep">
            <summary>
            Incoming step that gets the current <see cref="T:Rebus.Messages.TransportMessage"/> from the context and deserializes its body,
            saving the result as a <see cref="T:Rebus.Messages.Message"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Deserializes the incoming message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.TransportMessage"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.Message"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DispatchIncomingMessageStep">
            <summary>
            Incoming step that gets a <see cref="T:System.Collections.Generic.List`1"/> where T is <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> from the context
            and invokes them in the order they're in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.AbortDispatchContextKey">
            <summary>
            Keys of an <see cref="T:Rebus.Pipeline.IncomingStepContext"/> items that indicates that message dispatch must be stopped
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Processes the message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleDeferredMessagesStep">
            <summary>
            Incoming step that checks for the presence of the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header, using a
            <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to handle the deferral if necessary.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.#ctor(Rebus.Timeouts.ITimeoutManager,Rebus.Transport.ITransport,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the step, using the specified <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to defer relevant messages
            and the specified <see cref="T:Rebus.Transport.ITransport"/> to deliver messages when they're due.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Initialize">
            <summary>
            Initialized the step (starts the <see cref="F:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.DueMessagesSenderTaskName"/> background task if using the internal timeout manager)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks to see if the incoming message has the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header. If that is the case, the message is either stored for later delivery
            or forwarded to the configured external timeout manager. If not, the message will be passed on down the pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Dispose">
            <summary>
            Last-resort disposal of the due messages background task
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker">
            <summary>
            Wrapper of the handler that is ready to invoke
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.CanBeInitiatedBy(System.Type)">
            <summary>
            Gets whether a message of the given type is allowed to cause a new saga data instance to be created
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.HandlerInvoker.SagaDataSetters">
            <summary>
            Cached setter methods that "mount" a saga data instance on a handler (which is assumed to have a <code>Data</code> property, like <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker.Saga"/>
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.HandlerInvoker.CurrentHandlerInvokerItemsKey">
            <summary>
            Key under which the handler invoker will stash itself in the <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            during the invocation of the wrapped handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke">
            <summary>
            Method to call in order to invoke this particular handler
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.HasSaga">
            <summary>
            Gets whether this invoker's handler is a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Saga">
            <summary>
            Gets this invoker's handler as a saga (throws if it's not a saga)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Adds to the invoker a piece of saga data that has been determined to be relevant for the invocation
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.GetSagaData">
            <summary>
            Gets from the invoker the piece of saga data that has been determined to be relevant for the invocation, returning null if no such saga data has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SkipInvocation">
            <summary>
            Marks this handler as one to skip, i.e. calling this method will make the invoker ignore the call to <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke"/>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Handler">
            <summary>
            Gets the contained handler object (which is probably an implementation of <see cref="T:Rebus.Handlers.IHandleMessages"/>, but you should
            not depend on it!)
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.WillBeInvoked">
            <summary>
            <c>true</c> if the handler will be invoked, as per normal, <c>false</c> if <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker.SkipInvocation"/> has been called or the invoke will otherwise be skipped
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker`1">
            <summary>
            Derivation of the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> that has the message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.#ctor(System.Func{System.Threading.Tasks.Task},System.Object,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler">
            <summary>
            Gets the contained handler object
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.WillBeInvoked">
            <inheritdoc />
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga">
            <summary>
            Gets whther the contained handler object has a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga">
            <summary>
            If <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga"/> returned true, the <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler"/> can be retrieved as a <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga"/> here
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke">
            <summary>
            Invokes the handler within this handler invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Sets a saga instance on the handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.GetSagaData">
            <summary>
            Gets the saga data (if any) that was previously set with <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)"/>. Returns null
            if none has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SkipInvocation">
            <summary>
            Marks this handler invoker to skip its invocation, causing it to do nothin when <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke"/> is called
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvokers">
            <summary>
            Represents a sequence of handler invokers
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.#ctor(Rebus.Messages.Message,System.Collections.Generic.IEnumerable{Rebus.Pipeline.Receive.HandlerInvoker})">
            <summary>
            Constructs the sequence
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvokers.Message">
            <summary>
            Gets the logical message that the accompanying handler invokers are working on
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvokers.Count">
            <summary>
            Gets the number of handler invokers
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvokers.Item(System.Int32)">
            <summary>
            Gets the handler invoker with the given <paramref name="index"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.GetEnumerator">
            <summary>
            Gets all the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/>s that this <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/> contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleRoutingSlipsStep">
            <summary>
            Pipeline step that forwards routing slips when needed
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleRoutingSlipsStep.#ctor(Rebus.Transport.ITransport,Rebus.Serialization.ISerializer)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleRoutingSlipsStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the routing slip forwarding logic
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignDefaultHeadersStep">
            <summary>
            Outgoing step that sets default headers of the outgoing message.
            If the <see cref="F:Rebus.Messages.Headers.MessageId"/> header has not been set, it is set to a new GUID.
            If the bus is not a one-way client, the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to the address of the transport (unless the header has already been set to something else)
            If the <see cref="F:Rebus.Messages.Headers.SentTime"/> header has not been set, it is set to <see cref="P:System.DateTimeOffset.Now"/>.
            If the <see cref="F:Rebus.Messages.Headers.Type"/> header has not been set, it is set to the simple assembly-qualified name of the send message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDefaultHeadersStep.#ctor(Rebus.Transport.ITransport,Rebus.Time.IRebusTime,Rebus.Serialization.IMessageTypeNameConvention,System.String)">
            <summary>
            Constructs the step, getting the input queue address from the given <see cref="T:Rebus.Transport.ITransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDefaultHeadersStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the step and sets the default headers
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AutoHeadersOutgoingStep">
            <summary>
            Outgoing step that picks up <see cref="T:Rebus.Messages.HeaderAttribute"/> from the message type, automatically adding headers
            with <see cref="P:Rebus.Messages.HeaderAttribute.Key"/> set to <see cref="P:Rebus.Messages.HeaderAttribute.Value"/> if a header with such key has not already been added.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AutoHeadersOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the auto-header logic
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.DestinationAddresses">
            <summary>
            Encapsulates a list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.GetEnumerator">
            <summary>
            Gets all the addresses that this <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> object contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.FlowCorrelationIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.CorrelationId"/> header of the outgoing message if it has not already been set.
            The value used is one of the following (in prioritized order):
            1) The correlation ID of the message currently being handled,
            2) The message ID of the message currently being handled,
            3) The message's own message ID
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.FlowCorrelationIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Flows the correlation ID like it should
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SendOutgoingMessageStep">
            <summary>
            Outgoing step that uses the current transport to send the <see cref="T:Rebus.Messages.TransportMessage"/>
            found in the context to the destination address specified by looking up
            <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> in the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the specified transport to send the messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sends the outgoing message using the configured <see cref="T:Rebus.Transport.ITransport"/>, sending to the <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/>
            found in the <see cref="T:Rebus.Pipeline.OutgoingStepContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SerializeOutgoingMessageStep">
            <summary>
            Outgoing step that gets the current <see cref="T:Rebus.Messages.Message"/> from the context and serializes its body,
            saving the result as a <see cref="T:Rebus.Messages.TransportMessage"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Serializes the outgoing message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.Message"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.TransportMessage"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.ValidateOutgoingMessageStep">
            <summary>
            Outgoing message step that checks the consistency of the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.ValidateOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepContext">
            <summary>
            General step context model that encapsulates an object bag that can be used to pass data from step to step when executing a step pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.StepContext.StepContextKey">
            <summary>
            Key reserved for the step context when it is inserted into the current <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(``0)">
            <summary>
            Saves the given instance in the bag with a key derived from the (possibly explicitly specified) type <typeparamref name="T"/>
            Any instances currently stored under that type will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1">
            <summary>
            Loads the instance stored under the type <typeparamref name="T"/> using it as a key.
            Returns null if none could be found.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(System.String,``0)">
            <summary>
            Saves the given instance in the bag with the specified key. Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1(System.String)">
            <summary>
            Loads the instance stored under the specified key. Returns null if none could be found.
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.StepContext._index">
            <summary>
            Index-per-type counter that is incremented every time accessing <see cref="T:Rebus.Pipeline.StepContext.TypedId`1"/> causes a new type to be generated
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepContext.TypedId`1">
            <summary>
            Static type with static ID field that can automatically work as a type-to-index mapping
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepDocumentationAttribute">
            <summary>
            Documents the purpose of an <see cref="T:Rebus.Pipeline.IIncomingStep"/> or <see cref="T:Rebus.Pipeline.IOutgoingStep"/> which can then be used by tools to generate nice docs
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepDocumentationAttribute.#ctor(System.String)">
            <summary>
            Creates the attribute with the given documentation text. Will be included in the output
            when logging the message pipelines at startup, which is done by calling
            <code>.Options(o => o.LogPipeline(verbose: true|false))</code>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.StepDocumentationAttribute.Text">
            <summary>
            Gets the documentation text
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfiler">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IPipeline"/> that wraps another <see cref="T:Rebus.Pipeline.IPipeline"/>
            and injects instances of a single step into the pipeline which can be used to measure time spent
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.#ctor(Rebus.Pipeline.IPipeline,Rebus.Profiling.PipelineStepProfilerStats)">
            <summary>
            Creates the profiler
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.SendPipeline">
            <summary>
            Gets the original send pipeline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.ReceivePipeline">
            <summary>
            Gets a pipeline with time-tracking steps interleaved
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats">
            <summary>
            Stats collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetAndResetStats">
            <summary>
            Gets the current stats and resets the collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetStats">
            <summary>
            Gets the current stats
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats.StepStat">
            <summary>
            Represents an aggregation of measurements
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.StepType">
            <summary>
            Type of step for which this particular statistic was collected
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Elapsed">
            <summary>
            Time spent
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Percentage">
            <summary>
            Gets the percentage of time spent in this particular step
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.StepStat.ToString">
            <summary>
            Gets a string representation of this stat on the form "type: elapsed"
            </summary>
        </member>
        <member name="T:Rebus.Retry.ErrorTracking.InMemErrorTracker">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IErrorTracker"/> that tracks errors in an in-mem dictionary
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.#ctor(Rebus.Retry.Simple.RetryStrategySettings,Rebus.Threading.IAsyncTaskFactory,Rebus.Time.IRebusTime,Rebus.Retry.IExceptionLogger,Rebus.Retry.IExceptionInfoFactory)">
            <summary>
            Constructs the in-mem error tracker with the configured number of delivery attempts as the MAX
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Initialize">
            <summary>
            Initializes the in-mem error tracker - starts a background task that periodically cleans up tracked errors that haven't had any activity for 10 minutes or more
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.MarkAsFinal(System.String)">
            <summary>
            Marks the given <paramref name="messageId"/> as "FINAL", meaning that it should be considered as "having failed too many times now"
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            Registers the given <paramref name="exception"/> under the supplied <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether too many errors have been tracked for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Gets a long and detailed description of the tracked errors for the given <paramref name="messageId"/>
            consisting of time and full exception details for all registered exceptions
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.CleanUp(System.String)">
            <summary>
            Cleans up whichever tracking wr have done for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Dispose">
            <summary>
            Stops the periodic cleanup of tracked messages
            </summary>
        </member>
        <member name="T:Rebus.Retry.ErrorTracking.InMemErrorTrackerConfigurationExtensions">
            <summary>
            Configuration extension for the in-mem error tracker
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTrackerConfigurationExtensions.UseInMemErrorTracker(Rebus.Config.StandardConfigurer{Rebus.Retry.IErrorTracker})">
            <summary>
            Configures Rebus to track delivery attempts in memory. This is the default error tracker, so there's no need to explicitly call this method.
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTrackerConfigurationExtensions.UseInMemExceptionInfos(Rebus.Config.StandardConfigurer{Rebus.Retry.IErrorTracker})">
            <summary>
            Configures Rebus to use in-mem exception infos that provide the original exception via <see cref="M:Rebus.Retry.ExceptionInfo.ConvertTo``1"/>
            </summary>
        </member>
        <member name="T:Rebus.Retry.ExceptionInfo">
            <summary>
            Represents an <see cref="T:System.Exception"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ExceptionInfo.#ctor(System.String,System.String,System.String,System.DateTimeOffset)">
            <summary>
            Represents an <see cref="T:System.Exception"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ExceptionInfo.FromException(System.Exception)">
            <summary>
            Creates an <see cref="T:Rebus.Retry.ExceptionInfo"/> for the given <paramref name="exception"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ExceptionInfo.GetFullErrorDescription">
            <summary>
            Gets the full details of this exception info
            </summary>
        </member>
        <member name="M:Rebus.Retry.ExceptionInfo.ConvertTo``1">
            <summary>
            Treats the current exception info as an info of type <typeparamref name="TExceptionInfo"/>.
            </summary>
            <typeparam name="TExceptionInfo">Exception info subtype to convert to.</typeparam>
            <returns>This exception info cast to <typeparamref name="TExceptionInfo"/>.</returns>
        </member>
        <member name="T:Rebus.Retry.FailFast.FailFastChecker">
            <summary>
            Implementation of <seealso cref="T:Rebus.Retry.FailFast.IFailFastChecker"/> that determines that if an exception is
            <seealso cref="T:Rebus.Exceptions.FailFastException"/>, it should fail fast. Children of this class could
            further define additional logic to check if a message with exception should fail fast.
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.FailFastChecker.ShouldFailFast(System.String,System.Exception)">
            <summary>
            Checks if a message with exception should fail fast
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.FailFastConfigurationExtension">
            <summary>
            Extension methods for helping with configuration fail-fast behavior
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.FailFastConfigurationExtension.FailFastOn``1(Rebus.Config.OptionsConfigurer,System.Func{``0,System.Boolean})">
            <summary>
            Decorates the current <see cref="T:Rebus.Retry.FailFast.IFailFastChecker"/> with a filter that causes Rebus to fail fast on exceptions of type
            <typeparamref name="TException"/> (optionally also requiring it to satisfy the when <paramref name="when"/>)
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.IFailFastChecker">
            <summary>
            Service to check if a message should fail fast
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.IFailFastChecker.ShouldFailFast(System.String,System.Exception)">
            <summary>
            Checks if a message with specific exception should fail fast
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.ManualDeadletterCommand">
            <summary>
            Object that Rebus can add to its step context to signal to the retry step that it should immediately dead-letter the message being handled
            </summary>
        </member>
        <member name="P:Rebus.Retry.FailFast.ManualDeadletterCommand.Exception">
            <summary>
            Gets the exception passed via this command
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorHandler">
            <summary>
            Serivce that gets to handle failed messages
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,Rebus.Retry.ExceptionInfo)">
            <summary>
            Handles the poisonous message in the right way
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorTracker">
            <summary>
            Service that is responsible for tracking errors across message deliveries.
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            This method is called on each experienced failed delivery. 
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.CleanUp(System.String)">
            <summary>
            This method is called when there's no need to track the error anymore
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether the given message ID has had too many error registered for it
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Should get a full, detailed error description for the message ID (i.e. could be timestamps and full stack traces for all failed deliveries)
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.MarkAsFinal(System.String)">
            <summary>
            Marks the given <paramref name="messageId"/> as "FINAL", meaning that it should be considered as "having failed too many times now"
            </summary>
        </member>
        <member name="T:Rebus.Retry.IExceptionInfoFactory">
            <summary>
            An interface to handle the creation of portable, serializable, trackable <see cref="T:Rebus.Retry.ExceptionInfo"/>s.
            </summary>
        </member>
        <member name="M:Rebus.Retry.IExceptionInfoFactory.CreateInfo(System.Exception)">
            <summary>
            Create an <see cref="T:Rebus.Retry.ExceptionInfo"/> from an <see cref="T:System.Exception"/>.
            </summary>
            <param name="exception">Source exception.</param>
            <returns>An <see cref="T:Rebus.Retry.ExceptionInfo"/> containing information from the supplied exception.</returns>
        </member>
        <member name="T:Rebus.Retry.IExceptionLogger">
            <summary>
            Responsible for logging exceptions caught in handlers
            </summary>
        </member>
        <member name="M:Rebus.Retry.IExceptionLogger.LogException(System.String,System.Exception,System.Int32,System.Boolean)">
            <summary>
            Logs the exception in a nice way
            </summary>
        </member>
        <member name="T:Rebus.Retry.Info.InMemExceptionInfo">
            <summary>
            An in-memory exception info for in-memory error tracking.
            </summary>
        </member>
        <member name="M:Rebus.Retry.Info.InMemExceptionInfo.#ctor(System.Exception)">
            <summary>
            Constructs a new in-memory exception info from a source exception.
            </summary>
            <param name="exception">Source exception.</param>
        </member>
        <member name="P:Rebus.Retry.Info.InMemExceptionInfo.Exception">
            <summary>
            Gets or sets the original exception.
            </summary>
        </member>
        <member name="T:Rebus.Retry.Info.InMemExceptionInfoFactory">
            <summary>
            Creates <see cref="T:Rebus.Retry.ExceptionInfo"/>s by storing the original exception.
            </summary>
        </member>
        <member name="M:Rebus.Retry.Info.InMemExceptionInfoFactory.CreateInfo(System.Exception)">
            <summary>
            Create an <see cref="T:Rebus.Retry.ExceptionInfo"/> and store the original exception.
            </summary>
            <remarks>
            This factory only works/makes sense using an in-memory error tracker
            such as <see cref="T:Rebus.Retry.ErrorTracking.InMemErrorTracker"/>.
            </remarks>
            <param name="exception">Source exception.</param>
            <returns>An <see cref="T:Rebus.Retry.ExceptionInfo"/> containing information from the supplied exception.</returns>
        </member>
        <member name="T:Rebus.Retry.Info.ToStringExceptionInfoFactory">
            <summary>
            Creates <see cref="T:Rebus.Retry.ExceptionInfo"/>s using a simple ToString() method.
            </summary>
        </member>
        <member name="M:Rebus.Retry.Info.ToStringExceptionInfoFactory.CreateInfo(System.Exception)">
            <summary>
            Create an <see cref="T:Rebus.Retry.ExceptionInfo"/> from <see cref="M:System.Exception.ToString"/>.
            </summary>
            <param name="exception">Source exception.</param>
            <returns>An <see cref="T:Rebus.Retry.ExceptionInfo"/> containing information from the supplied exception.</returns>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategy">
            <summary>
            Determines the retry strategy by providing an implementation of <see cref="T:Rebus.Retry.Simple.IRetryStep"/> which will be
            put in front of the incoming message pipeline
            </summary>
        </member>
        <member name="M:Rebus.Retry.IRetryStrategy.GetRetryStep">
            <summary>
            Should return a <see cref="T:Rebus.Retry.Simple.IRetryStep"/> which is an <see cref="T:Rebus.Pipeline.IIncomingStep"/> that implements the retry strategy
            </summary>
        </member>
        <member name="T:Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler">
            <summary>
            Default <see cref="T:Rebus.Retry.IErrorHandler"/> that uses a "poison queue" to function as storage for failed messages.
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler.#ctor(Rebus.Retry.Simple.RetryStrategySettings,Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the error handler
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler.Initialize">
            <summary>
            Initializes the poison queue error handler by creating the error queue if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,Rebus.Retry.ExceptionInfo)">
            <summary>
            Handles the poisonous message by forwarding it to the configured error queue
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.DefaultRetryStep">
            <summary>
            Incoming message pipeline step that implements a retry mechanism - if the call to the rest of the pipeline fails,
            the exception is caught and the queue transaction is rolled back. Caught exceptions are tracked with <see cref="T:Rebus.Retry.IErrorTracker"/>, and after
            a configurable number of retries, the message will be passed to the configured <see cref="T:Rebus.Retry.IErrorHandler"/>.
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.DefaultRetryStep.DispatchAsFailedMessageKey">
            <summary>
            Key of a step context item that indicates that the message must be wrapped in a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> after being deserialized
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.DefaultRetryStep.#ctor(Rebus.Logging.IRebusLoggerFactory,Rebus.Retry.IErrorHandler,Rebus.Retry.IErrorTracker,Rebus.Retry.FailFast.IFailFastChecker,Rebus.Retry.IExceptionInfoFactory,Rebus.Retry.Simple.RetryStrategySettings,System.Threading.CancellationToken)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.DefaultRetryStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the entire message processing pipeline in an exception handler, tracking the number of failed delivery using <see cref="T:Rebus.Retry.IErrorTracker"/>.
            Passes the message to the <see cref="T:Rebus.Retry.IErrorHandler"/> when the max number of delivery attempts has been exceeded.
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.DefaultRetryStrategy">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IRetryStrategy"/> that tracks errors in memory
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.DefaultRetryStrategy.#ctor(Rebus.Retry.Simple.RetryStrategySettings,Rebus.Logging.IRebusLoggerFactory,Rebus.Retry.IErrorTracker,Rebus.Retry.IErrorHandler,Rebus.Retry.FailFast.IFailFastChecker,Rebus.Retry.IExceptionInfoFactory,System.Threading.CancellationToken)">
            <summary>
            Constructs the retry strategy with the given settings, creating an error queue with the configured name if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.DefaultRetryStrategy.GetRetryStep">
            <summary>
            Gets the retry step with appropriate settings for this <see cref="T:Rebus.Retry.Simple.DefaultRetryStrategy"/>
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.FailedMessageWrapper`1">
            <summary>
            Wraps a failed message that is to be retried
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this <see cref="T:Rebus.Retry.Simple.IFailed`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},`0,System.String,System.Collections.Generic.IEnumerable{Rebus.Retry.ExceptionInfo})">
            <summary>
            Constructs the wrapper with the given message
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.ToString">
            <summary>
            Returns a string that represents the current failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.IFailed`1">
            <summary>
            Interface of the wrapper of a failed message
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.IRetryStep">
            <summary>
            Marker interface for the retry step
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.RetryStrategyConfigurationExtensions">
            <summary>
            Configuration extensions for the simple retry strategy
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.RetryStrategyConfigurationExtensions.RetryStrategy(Rebus.Config.OptionsConfigurer,System.String,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>
            Configures the simple retry strategy, using the specified error queue address and number of delivery attempts
            </summary>
            <param name="optionsConfigurer">(extension method target)</param>
            <param name="errorQueueName">Specifies the name of the error queue</param>
            <param name="maxDeliveryAttempts">Specifies how many delivery attempts should be made before forwarding a failed message to the error queue</param>
            <param name="secondLevelRetriesEnabled">Specifies whether second level retries should be enabled - when enabled, the message will be dispatched wrapped in an <see cref="T:Rebus.Retry.Simple.IFailed`1"/> after the first <paramref name="maxDeliveryAttempts"/> delivery attempts, allowing a different handler to handle the message. Dispatch of the <see cref="T:Rebus.Retry.Simple.IFailed`1"/> is subject to the same <paramref name="maxDeliveryAttempts"/> delivery attempts</param>
            <param name="errorDetailsHeaderMaxLength">Specifies a MAX length of the error details to be enclosed as the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header. As the enclosed error details can sometimes become very long (especially when using many delivery attempts), depending on the transport's capabilities it might sometimes be necessary to truncate the error details</param>
            <param name="errorTrackingMaxAgeMinutes">Specifies the max age of in-mem error trackings, for tracked messages that have not had any activity registered on them.</param>
            <param name="errorQueueErrorCooldownTimeSeconds">Specifies the time in seconds that the bus instance will wait if forwarding to the dead-letter queue fails.</param>
        </member>
        <member name="T:Rebus.Retry.Simple.RetryStrategySettings">
            <summary>
            Contains the settings used by <see cref="T:Rebus.Retry.Simple.DefaultRetryStrategy"/>
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultErrorQueueName">
            <summary>
            Name of the default error queue, which will be used unless <see cref="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorQueueName"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultNumberOfDeliveryAttempts">
            <summary>
            Number of delivery attempts that will be used unless <see cref="P:Rebus.Retry.Simple.RetryStrategySettings.MaxDeliveryAttempts"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultErrorTrackingMaxAgeMinutes">
            <summary>
            Default age in minutes of an in-mem error tracking, which will be used unless <see cref="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorTrackingMaxAgeMinutes"/> is set to something else.
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultErrorQueueErrorCooldownTimeSeconds">
            <summary>
            Default time in seconds the bus instance will wait, if forwarding to dead-letter queue fails.
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.RetryStrategySettings.#ctor(System.String,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the settings with the given error queue address and number of delivery attempts, defaulting to <see cref="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultErrorQueueName"/> and <see cref="F:Rebus.Retry.Simple.RetryStrategySettings.DefaultNumberOfDeliveryAttempts"/> 
            as the error queue address and number of delivery attempts, respectively
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorQueueName">
            <summary>
            Name of the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.MaxDeliveryAttempts">
            <summary>
            Number of attempted deliveries to make before moving the poisonous message to the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.SecondLevelRetriesEnabled">
            <summary>
            Configures whether an additional round of delivery attempts should be made with a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> wrapping the originally failed messageS
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorDetailsHeaderMaxLength">
            <summary>
            Configures the max length of the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header. Depending on the configured number of delivery attempts and the transport's capabilities, it might
            be necessary to truncate the value of this header.
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorTrackingMaxAgeMinutes">
            <summary>
            Configures the maximum age in minutes of an in-mem error tracking.
            This is a safety precaution, because the in-mem error tracker can end up tracking messages that it never sees
            again if multiple bus instances are consuming messages from the same queue.
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.RetryStrategySettings.ErrorQueueErrorCooldownTimeSeconds">
            <summary>
            Configures time in seconds the bus instance will wait, if forwarding to dead-letter queue fails.
            </summary>
        </member>
        <member name="T:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions">
            <summary>
            Configuration extensions for configuring automatic forwarding on certain exception types
            </summary>
        </member>
        <member name="M:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions.ForwardOnException``1(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.String,Rebus.Logging.LogLevel,System.Func{``0,System.Boolean})">
            <summary>
            Short-circuits the usual retry strategy by immediately forwarding the transport message to the specified queue when an
            exception of the type specified by <typeparamref name="TException"/> is caught. Please note that any outgoing message
            that have already been sent WILL BE SENT because the queue transaction is not rolled back.
            Use <paramref name="logLevel"/> to specify which log level to use when logging the forwarding action.
            </summary>
        </member>
        <member name="T:Rebus.Routing.IRouter">
            <summary>
            Abstraction of the routing logic. Should be capable of returning a destination address for a message
            and an owner address for a topic.
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="T:Rebus.Routing.Itinerary">
            <summary>
            Represents a list of destinations that the routing slip must visit
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.#ctor(System.String[])">
            <summary>
            Initializes the itinerary with the given list of <paramref name="destinationAddresses"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.Add(System.String)">
            <summary>
            Adds the given <paramref name="destinationAddress"/> to the itinerary
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.ReturnTo(System.String)">
            <summary>
            Indicates that the routing slip must be returned to <paramref name="destinationAddress"/> when done
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.ReturnToSender">
            <summary>
            Indicates that the routing slip must be returned to the sender when done
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.None">
            <summary>
            Doesn't do anything - dispatches the message as normally
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.Forward">
            <summary>
            Forwards the message to one or more recipients
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.Ignore">
            <summary>
            Ignores the message (thus effectively losing it)
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ErrorBehavior">
            <summary>
            Options on how to handle exceptions when attempting to forward transport messages
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ErrorBehavior.RetryForever">
            <summary>
            Indicates that no error handling should be done. This puts the burden of handling errors into the hands
            of the implementor of the transport message forwarding function, and thus it should handle errors by
            forwarding the message somewhere else
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ErrorBehavior.Normal">
            <summary>
            Indicates that the transport message should be passed to the error handler when there is an error, which
            usually means that the message is moved to the error queue.
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardAction">
            <summary>
            Represents some action to perform with the incoming transport message. Must be created via the static functions
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ForwardAction.None">
            <summary>
            Gets an action that causes the message to be handled normally
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.String)">
            <summary>
            Gets an action that causes the message to be forwarded to the queue specified by <paramref name="destinationQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets an action that causes the message to be forwarded to the queues specified by <paramref name="destinationQueueNames"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.Ignore">
            <summary>
            Gets an action that causes the messge to be ignored. THIS WILL EFFECTIVELY LOSE THE MESSAGE
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardTransportMessageStep">
            <summary>
            Incoming message step that looks at the transport message and possibly forwards it to another queue
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.#ctor(System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory,Rebus.Routing.TransportMessages.ErrorBehavior,Rebus.Retry.IErrorHandler,Rebus.Retry.IExceptionInfoFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes the routing function and performs some action depending on the returned <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> result
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions">
            <summary>
            Configuration extensions for very fast filtering and forwarding of incoming transport messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}})">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Routing.TransportMessages.ErrorBehavior)">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouter">
            <summary>
            Routing logic that maps types to owning endpoints.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the router
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyDerivedFrom``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TDerivedFrom"/>
            and derived from <typeparamref name="TDerivedFrom"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyDerivedFrom(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="derivedFrom"/>
            and optionally derived from <paramref name="derivedFrom"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyNamespaceOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyNamespaceOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyNamespaceOfDerivedFrom``2(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/> under
            the namespace that type lives under and derived from <typeparamref name="TDerivedFrom"/>. So all types within the same namespace will
            get mapped to that destination address, but not types under other namespaces. This allows you to separate messages for specific queues by
            namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyNamespaceOfDerivedFrom(System.Type,System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/> under
            the namespace that type lives under and derived from <paramref name="derivedFrom"/>. So all types within the same namespace will
            get mapped to that destination address, but not types under other namespaces. This allows you to separate messages for specific queues by
            namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapFallback(System.String)">
            <summary>
            Configures <paramref name="destinationAddress"/> as a fallback which will be returned when trying to get a destination for an unmapped type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Gets the destination address for the given message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Looks up the owner of the topic which is assumed to be an assembly-qualified name of an available .NET type
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions">
            <summary>
            Configuration extensions for configuring type-based routing (i.e. routing where each message type has one, single unambiguous
            owning endpoint)
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Configures Rebus to use type-based routing
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder">
            <summary>
            Type-based routing configuration builder that can be called fluently to map message types to their owning endpoints
            </summary>
        </member>
        <member name="F:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder._configurationActions">
            <summary>
            We use this way of storing configuration actions in order to preserve the order
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyDerivedFrom``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TDerivedFrom"/>
            and derived from <typeparamref name="TDerivedFrom"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyNamespaceOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyNamespaceOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyNamespaceOfDerivedFrom``2(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyNamespaceOfDerivedFrom(System.Type,System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/> under
            the namespace that type lives under. So all types within the same namespace will get mapped to that destination address, but not types under
            other namespaces. This allows you to separate messages for specific queues by namespace and register them all in one go.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapFallback(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as a fallback destination to use when none of the configured mappings match
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Conflicts.SagaConflictResolutionConfigurationExtensions">
            <summary>
            Configuration extensions for customizing conflict resolution
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Conflicts.SagaConflictResolutionConfigurationExtensions.SetMaxConflictResolutionAttempts(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Int32)">
            <summary>
            Sets maximum number of times conflict resolution is invoked. Only relevant in cases where <see cref="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)"/> is implemented in a
            saga handler. If the value is set to 0, conflict resolution is disabled even though the <see cref="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)"/> is implemented.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.CorrelationProperty">
            <summary>
            Represents a mapping from a field of an incoming message of a specific type to a specific property on a specific type of saga data
            </summary>
        </member>
        <member name="F:Rebus.Sagas.CorrelationProperty.AllowedCorrelationPropertyTypes">
            <summary>
            Defines the types that are allowed to use with saga data properties that are intended for correlation
            </summary>
        </member>
        <member name="M:Rebus.Sagas.CorrelationProperty.#ctor(System.Type,System.Func{Rebus.Pipeline.IMessageContext,Rebus.Messages.Message,System.Object},System.Type,System.String,System.Type)">
            <summary>
            Constructs the correlation property
            </summary>
            <param name="messageType">Specifies the message type that this property can correlate</param>
            <param name="getValueFromMessage">Specifies the function that will be called with the message instance in order to extract a value that should be used for correlation</param>
            <param name="sagaDataType">Specifies the type of saga data that this property can correlate to</param>
            <param name="propertyName">Specifies that property name on the saga data that this correlation addresses</param>
            <param name="sagaType">Specifies the saga type (i.e. the handler type) that contains the logic of the saga</param>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.MessageType">
            <summary>
            The message type that this property can correlate
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.GetValueFromMessage">
            <summary>
            The function that will be called with the message instance in order to extract a value that should be used for correlation
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga's saga data
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.PropertyName">
            <summary>
            Gets the name of the correlation property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaType">
            <summary>
            The saga type (i.e. the handler type) that contains the logic of the saga
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStepBase.GetHashCodeStable(System.String)">
            <summary>
            Cannot use <see cref="M:System.Object.GetHashCode"/>, because it's not stable across processes in modern .NET
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions">
            <summary>
            Configuration extensions for optional in-process locking of saga instances
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions.EnforceExclusiveAccess(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Int32)">
            <summary>
            Forces exclusive access
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions.EnforceExclusiveAccess(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},Rebus.ExclusiveLocks.IExclusiveAccessLock,System.String,System.Int32)">
            <summary>
            Forces exclusive access using a lockhandler defined by <see cref="T:Rebus.ExclusiveLocks.IExclusiveAccessLock"/>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions.EnforceExclusiveAccess(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Func{Rebus.Injection.IResolutionContext,Rebus.ExclusiveLocks.IExclusiveAccessLock},System.String,System.Int32)">
            <summary>
            Forces exclusive access using a lockhandler defined by <see cref="T:Rebus.ExclusiveLocks.IExclusiveAccessLock"/>, materialized via a callback within the resolution context
            </summary>
        </member>
        <member name="T:Rebus.Sagas.IAmInitiatedBy`1">
            <summary>
            Derived marker interface, allowing for a handler to indicate that messages of type <typeparamref name="TMessage"/> 
            are allowed to instantiate new saga instances if the message cannot be correlated with an already existing instance
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ICorrelationConfig`1">
            <summary>
            Sets up the saga instance correlation configuration, i.e. it configures how the following question should be answered:
            "given this incoming message, how should Rebus figure out which saga instance should be loaded to handle it?"
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/>, using the specified <paramref name="messageValueExtractorFunction"/> to
            extract a value from the message. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.Correlate&lt;TradeApproved&gt;(t => t.Id, d => d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "Id" property of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="messageValueExtractorFunction">Configures a function to extract a value from the message. Since this is just a function, it may contain logic that e.g. concatenates fields, calls other functions, etc.</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.String)">
            <summary>
            An overload of <see cref="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/> that allows the saga
            data property that is used for correlation to be specified as a string.
            You could for example do something like this:
            <code>
            config.Correlate&lt;TradeApproved&gt;(t => t.Id, nameof(ApprovedTradeSagaData.TradeId));
            </code>
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="messageValueExtractorFunction">Configures a function to extract a value from the message. Since this is just a function, it may contain logic that e.g.
            concatenates fields, calls other functions, etc.</param>
            <param name="sagaDataPropertyName">The name of the property of the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> that will be used when querying for the correlation value. It must
            point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateHeader``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/> using the header with the given <paramref name="headerKey"/>. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.CorrelateHeader&lt;TradeApproved&gt;("trade-corr-id", d => d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "trade-corr-id" header of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="headerKey">Configures a header key which will be extracted from the incoming message</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateHeader``1(System.String,System.String)">
            <summary>
            An overload of <see cref="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateHeader``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/> that allows the saga
            data property that is used for correlation to be specified as a string.
            You could for example do something like this:
            <code>
            config.CorrelateHeader&lt;TradeApproved&gt;("trade-corr-id", nameof(ApprovedTradeSagaData.TradeId));
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "trade-corr-id" header of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="headerKey">Configures a header key which will be extracted from the incoming message</param>
            <param name="sagaDataPropertyName">The name of the property of the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> that will be used when querying for the correlation value. It must
            point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateContext``1(System.Func{Rebus.Pipeline.IMessageContext,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/> using the message context to get a value (e.g. by selecting certain headers, combining them, etc)
             The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="contextValueExtractorFunction">Configures a function that can extract a value from the current <see cref="T:Rebus.Pipeline.IMessageContext"/></param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateContext``1(System.Func{Rebus.Pipeline.IMessageContext,System.Object},System.String)">
            <summary>
            An overload of <see cref="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateContext``1(System.Func{Rebus.Pipeline.IMessageContext,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>
            that allows correlation an incoming message of type <typeparamref name="TMessage"/> using the message context to get a value (e.g. by selecting certain headers, combining them, etc)
             The value will be used when looking up a saga data instance is the value of the property whose name is specified by <paramref name="sagaDataPropertyName"/>.
            You could for example do something like this:
            <code>
            config.CorrelateContext&lt;TradeApproved&gt;(t => t.Id, nameof(ApprovedTradeSagaData.TradeId));
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "Id" property of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="contextValueExtractorFunction">Configures a function that can extract a value from the current <see cref="T:Rebus.Pipeline.IMessageContext"/></param>
            <param name="sagaDataPropertyName">The name of the property of the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> that will be used when querying for the correlation value. It must
            point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="T:Rebus.Sagas.ICorrelationErrorHandler">
            <summary>
            Interface of Rebus' correlation error handler, which will be invoked when an incoming message cannot be correlated
            with an existing instance of saga data, and the message is not allowed to initiate a new saga.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationErrorHandler.HandleCorrelationError(Rebus.Sagas.SagaDataCorrelationProperties,Rebus.Pipeline.Receive.HandlerInvoker,Rebus.Messages.Message)">
            <summary>
            This method will be invoked when an incoming message cannot be correlated
            with an existing instance of saga data, and the message is not allowed to initiate a new saga.
            </summary>
            <param name="correlationProperties">
            Full collection of <see cref="T:Rebus.Sagas.CorrelationProperty"/> instances available for this Rebus instance. Call <see cref="M:Rebus.Sagas.SagaDataCorrelationProperties.ForMessage(System.Object)"/>
            </param>
            <param name="handlerInvoker"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotencyData">
            <summary>
            This chunk of data help with tracking handled messages and externally visible behavior (i.e. outbound messages) from handling each message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.#ctor(System.Collections.Generic.IEnumerable{Rebus.Sagas.Idempotent.OutgoingMessages},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates the idempotency data object, initializing it with the given list of outgoing message lists and record of handled message IDs
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.OutgoingMessages">
            <summary>
            Gets the outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.HandledMessageIds">
            <summary>
            Getst the IDs of all messages that have been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.HasAlreadyHandled(System.String)">
            <summary>
            Gets whether the message with the given ID has already been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.GetOutgoingMessages(System.String)">
            <summary>
            Gets the outgoing messages for the incoming message with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.MarkMessageAsHandled(System.String)">
            <summary>
            Marks the message with the given ID as handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.AddOutgoingMessage(System.String,System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Adds the <see cref="T:Rebus.Messages.TransportMessage"/> as an outgoing message destined for the addresses specified by <paramref name="destinationAddresses"/>
            under the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSaga`1">
            <summary>
            Sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> are sagas that guarantee idempotency by guarding against
            handling the same message twice by tracking IDs of handled messages
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions">
            <summary>
            Configuration extension for the idempotent sagas feature (allows for guaranteeing that a saga instance does not handle the same
            message twice, even in the face of at-least-once delivery guarantees and retries due to transport layer failures)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions.EnableIdempotentSagas(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables idempotent sagas. When enabled, sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> can be truly idempotent.
            This means that the saga instance stores the IDs of all handled messages, including all outgoing messages send when handling
            each incoming message - this way, the saga instance can guard itself against handling the same message twice, while still
            preserving externally visible behavior even when a message gets handled more than once.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaData">
            <summary>
            Convenient standard implementation of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep">
            <summary>
            Incoming pipeline step that checks the loaded saga data to see if the message currently being handled is a dupe.
            If it is, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message
            will be sent 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks the loaded saga data to see if the message currently being handled is a duplicate of a message that has previously been handled. 
            If that is the case, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message will be sent.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep">
            <summary>
            Outgoing pipeline step that stores the sent message in the current saga data (if it is an <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IIdempotentSagaData">
            <summary>
            Derivation of <see cref="T:Rebus.Sagas.ISagaData"/> that is capable of storing externally visible side-effects (i.e. outgoing messages)
            that were caused by handling specific incoming messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IIdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessage">
            <summary>
            An outgoing message is a <see cref="T:Rebus.Messages.TransportMessage"/> destined for one or more destinations. It is meant to be stored
            in an <see cref="T:Rebus.Sagas.Idempotent.IdempotencyData"/> instance inside an instance of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessage.#ctor(System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the outgoing message destined for the given addresses
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.DestinationAddresses">
            <summary>
            Gets the addresses for which this <see cref="T:Rebus.Messages.TransportMessage"/> is supposed to be sent
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.TransportMessage">
            <summary>
            Gets the transport message
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessages">
            <summary>
            Contains all the <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances for a given incoming message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.#ctor(System.String,System.Collections.Generic.IEnumerable{Rebus.Sagas.Idempotent.OutgoingMessage})">
            <summary>
            Constructs the instance for the given message ID, containing the given <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId">
            <summary>
            Gets the ID of the incoming message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessagesToSend">
            <summary>
            Gets all the outgoing messages to be sent as a consequence of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.Add(Rebus.Sagas.Idempotent.OutgoingMessage)">
            <summary>
            Adds another <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> as a side-effect of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaCorrelationProperty">
            <summary>
            Represents a path to a correlation property on a saga of a specific type
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga data
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaData">
            <summary>
            Interface of a saga data instance. The saga data represents the state of the state machine instance of the process manager,
            that the saga essentially implements.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaStorage">
            <summary>
            Abstraction for a mechanism that is capable of storing saga state, retrieving it again by querying for value on the state
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Finds an already-existing instance of the given saga data type that has a property with the given <paramref name="propertyName"/>
            whose value matches <paramref name="propertyValue"/>. Returns null if no such instance could be found
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data as a new instance. Throws a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another saga data instance
            already exists with a correlation property that shares a value with this saga data.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the already-existing instance of the given saga data, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another
            saga data instance exists with a correlation property that shares a value with this saga data, or if the saga data
            instance no longer exists.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the saga data instance, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if the instance no longer exists
            </summary>
        </member>
        <member name="T:Rebus.Sagas.LoadSagaDataStep">
            <summary>
            Incoming step that loads and saves relevant saga data.
            </summary>
        </member>
        <member name="F:Rebus.Sagas.LoadSagaDataStep.IgnoredProperties">
            <summary>
            properties ignored by auto-setter (the one that automatically sets the correlation ID on a new saga data instance)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.#ctor(Rebus.Sagas.ISagaStorage,Rebus.Sagas.ICorrelationErrorHandler,Rebus.Logging.IRebusLoggerFactory,Rebus.Config.Options)">
            <summary>
            Constructs the step with the given saga storage
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            For each <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> found in the current <see cref="T:Rebus.Pipeline.IncomingStepContext"/>'s <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>,
            this step will see if the invoker's handler is actually a <see cref="T:Rebus.Sagas.Saga"/>. If that is the case, the saga's correlation properties
            are used to see if a piece of existing saga data can be retrieved and mounted on the <see cref="P:Rebus.Sagas.Saga`1.Data"/> property.
            If no existing instance was found, but the saga implements <see cref="T:Rebus.Sagas.IAmInitiatedBy`1"/> for the current message,
            a new saga data instance will be created (and mounted). Otherwise, the message is ignored.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga">
            <summary>
            Saga base class that allows for passing around saga instances without being bothered by the type of saga data they're handling. You should
            probably not inherit from this one, inherit your saga from <see cref="T:Rebus.Sagas.Saga`1"/> instead.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.UserHasOverriddenConflictResolutionMethod">
            <summary>
            Checks whether the <see cref="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)"/> method is defined in <see cref="T:Rebus.Sagas.Saga`1"/>, returning
            true if it is NOT - because that means that the user has overridden the method and in this particular saga type can resolve conflicts.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsComplete">
            <summary>
            Marks the current saga instance as completed, which means that it is either a) deleted from persistent storage in case
            it has been made persistent, or b) thrown out the window if it was never persisted in the first place.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsUnchanged">
            <summary>
            Marks the current saga instance as unchanged, causing any changes made to it to be ignored. Its revision will NOT be
            incremented
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga.IsNew">
            <summary>
            Gets whether the saga data instance is new
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga`1">
            <summary>
            Generic saga base class that must be made concrete by supplying the <typeparamref name="TSagaData"/> type parameter.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga`1.Data">
            <summary>
            Gets or sets the relevant saga data instance for this saga handler
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.CorrelateMessages(Rebus.Sagas.ICorrelationConfig{`0})">
            <summary>
            This method must be implemented in order to configure correlation of incoming messages with existing saga data instances.
            Use the injected <see cref="T:Rebus.Sagas.ICorrelationConfig`1"/> to set up the correlations, e.g. like so:
            <code>
            config.Correlate&lt;InitiatingMessage&gt;(m => m.OrderId, d => d.CorrelationId);
            config.Correlate&lt;CorrelatedMessage&gt;(m => m.CorrelationId, d => d.CorrelationId);
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)">
            <summary>
            Override this to be given an opportunity to resolve the conflict when a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> occurs on an update.
            If a conflict cannot be resolved, feel free to bail out by throwing an exception.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaCorrelationConfigurationExtensions">
            <summary>
            Configuration extensions for additional saga-related things
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaCorrelationConfigurationExtensions.UseCorrelationErrorHandler(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},Rebus.Sagas.ICorrelationErrorHandler)">
            <summary>
            Adds the given <paramref name="correlationErrorHandler"/> as the <see cref="T:Rebus.Sagas.ICorrelationErrorHandler"/>, which gets invoked each time
            Rebus cannot correlate a message with an ongoing saga (and the given message is not allowed to start a new one)
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaData">
            <summary>
            Convenient implementation of <see cref="T:Rebus.Sagas.ISagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaDataCorrelationProperties">
            <summary>
            Contains a set of correlation properties relevant for one particular saga data
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.IReadOnlyList{Rebus.Sagas.CorrelationProperty}},System.Type)">
            <summary>
            Constructs the set
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.ForMessage(System.Object)">
            <summary>
            Looks up correlation properties relevant for the specified message type
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.GetEnumerator">
            <summary>
            Gets the correlation properties contained in this collection
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaHelper">
            <summary>
            Helper class that can cache configured sets of correlation properties for various saga types
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.GetCorrelationProperties(Rebus.Sagas.Saga)">
            <summary>
            Gets (most likely from a cache) the set of correlation properties relevant for the given saga handler.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.CreateNewSagaData(Rebus.Sagas.Saga)">
            <summary>
            Creates a new instance of the saga's saga data
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder">
            <summary>
            Builder for configuring <see cref="T:Rebus.Serialization.Custom.CustomTypeNameConvention"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AddWithShortNames(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Adds all of the given <paramref name="types"/> with their "short names",
            i.e. without assembly or namespace information. Please note that nested classes have names that include their parent classes.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AddWithShortName``1">
            <summary>
            Adds the type <typeparamref name="T"/> with its "short name",
            i.e. without assembly or namespace information. Please note that nested classes have names that include their parent classes.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AddWithShortName(System.Type)">
            <summary>
            Adds the type <paramref name="type"/> with its "short name",
            i.e. without assembly or namespace information. Please note that nested classes have names that include their parent classes.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AddWithCustomName``1(System.String)">
            <summary>
            Adds the type <typeparamref name="T"/> with the name <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AddWithCustomName(System.Type,System.String)">
            <summary>
            Adds the type <paramref name="type"/> with the name <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionBuilder.AllowFallbackToDefaultConvention">
            <summary>
            Allows for falling back to the default behavior in cases where type mappings have not been added explicitly
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Custom.CustomTypeNameConventionExtensions">
            <summary>
            Extensions to help with configuring custom message type names
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Custom.CustomTypeNameConventionExtensions.UseCustomMessageTypeNames(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer})">
            <summary>
            Installs a message type name convention that can be customized by making further calls to the builder returned from this method.
            This can be used to improve interoperability of messages, as e.g.
            <code>
            Configure.With(...)
                .(...)
                .Serialization(s => {
                    s.UseCustomMessageTypeNames()
                        .AddWithCustomName&lt;SomeType&gt;("SomeType");
                })
                .Start();
            </code>
            This will make Rebus put the type name "SomeType" in the <see cref="F:Rebus.Messages.Headers.Type"/> header, thus removing all of the .NET-specific
            stuff like namespace and assembly information.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.DictionarySerializer">
            <summary>
            Generic serializer that serializes <see cref="T:System.Collections.Generic.Dictionary`2"/> of <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values
            into JSON and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Serializes the given dictionary into a JSON string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given JSON string into a dictionary
            </summary>
        </member>
        <member name="T:Rebus.Serialization.GenericJsonSerializer">
            <summary>
            Generic serializer that serializes an object into a string and vice versa. Uses a normal, compact JSON format,
            requiring the serialized type to be known at deserialization time
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given object to a string. No type information is included - therefore, abstract members etc.
            cannot be reproduced when deserializing
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Deserialize``1(System.String)">
            <summary>
            Deserializes the given JSON string to the type specified
            </summary>
        </member>
        <member name="T:Rebus.Serialization.HeaderSerializer">
            <summary>
            Simple serializer that can be used to encode/decode headers to/from bytes
            </summary>
        </member>
        <member name="P:Rebus.Serialization.HeaderSerializer.Encoding">
            <summary>
            Configures which encoding to use for encoding the string of headers to/from bytes
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Encodes the headers into a string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.Serialize(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Encodes the headers into a byte array
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.Deserialize(System.Byte[])">
            <summary>
            Decodes the headers from the given byte array
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.DeserializeFromString(System.String)">
            <summary>
            Decodes the headers from the given string
            </summary>
        </member>
        <member name="T:Rebus.Serialization.IMessageTypeNameConvention">
            <summary>
            Defines how Rebus by default will map the names of types back and forth. This is used to populate the
            <see cref="F:Rebus.Messages.Headers.Type"/> header of outgoing messages, and it might be used also by whichever message
            serializer is going to work on the messages.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.IMessageTypeNameConvention.GetTypeName(System.Type)">
            <summary>
            Responsible for getting an appropriate name for the given <paramref name="type"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.IMessageTypeNameConvention.GetType(System.String)">
            <summary>
            Responsible for getting the type that corresponds to the given <paramref name="name"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ISerializer">
            <summary>
            Message serializer that should capable of safely roundtripping .NET message body objects to some serialized form and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.JsonInteroperabilityMode">
            <summary>
            Enumerates levels of type information included in the serialized format
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonInteroperabilityMode.FullTypeInformation">
            <summary>
            Includes full .NET type information in the serialized format. This is the preferred option
            if rich message types with subclasses and interfaces are desired, but it might break
            interoperatbility (e.g. because <see cref="T:System.Collections.Generic.List`1"/> might not be in the same namespace
            between .NET full FX / .NET Core, or because the type information has no meaningful 
            representation on another platform like e.g. node.js).
            Moreover, message sizes should be considered, as this format takes up more space on the wire
            (depending on how messages are modeled of course)
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonInteroperabilityMode.PureJson">
            <summary>
            Uses plain JSON in the serialized format, only including the full .NET name of the
            message type in a header of the message. This makes for a compact and clean serialization,
            making messages more accessible to other platforms.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.JsonSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.Serialization.ISerializer"/> that uses Newtonsoft JSON.NET internally, with some pretty robust settings
            (i.e. full type info is included in the serialized format in order to support deserializing "unknown" types like
            implementations of interfaces, etc)
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonSerializer.JsonUtf8ContentType">
            <summary>
            Proper content type when a message has been serialized with this serializer (or another compatible JSON serializer) and it uses the standard UTF8 encoding
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonSerializer.JsonContentType">
            <summary>
            Contents type when the content is JSON
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonSerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions">
            <summary>
            Configuration extensions for the honest Newtonsoft JSON.NET-based Rebus message serializer
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer})">
            <summary>
            Configures Rebus to use Newtonsoft JSON.NET to serialize messages, using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> that includes ALL
            type information in every object, thus allowing for preserving all type information when roundtripping message types.
            Message bodies are UTF8-encoded.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer},Rebus.Serialization.Json.JsonInteroperabilityMode)">
            <summary>
            Configures Rebus to use Newtonsoft JSON.NET to serialize messages, using appropriate <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> 
            depending on the given <paramref name="mode"/>. Message bodies are UTF8-encoded.
            Passing <see cref="F:Rebus.Serialization.Json.JsonInteroperabilityMode.FullTypeInformation"/> as the value for <paramref name="mode"/> is equivalent
            to calling <see cref="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer})"/> 
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer},Newtonsoft.Json.JsonSerializerSettings,System.Text.Encoding)">
            <summary>
            Configures Rebus to use Newtonsoft JSON.NET to serialize messages, using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> and 
            This allows you to customize almost every aspect of how messages are actually serialized/deserialized.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.SystemJsonConfigurationExtensions">
            <summary>
            Configuration extensions for the .NET System.Text.Json Rebus message serializer
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.SystemJsonConfigurationExtensions.UseSystemTextJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer})">
            <summary>
            Configures Rebus to use .NET System.Text.Json to serialize messages.
            Default <see cref="T:System.Text.Json.JsonSerializerOptions" /> settings, except trailing commas are allowed, and comments are skipped.
            Message bodies are UTF8-encoded.
            This is the default message serialization, so there is actually no need to call this method.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.SystemJsonConfigurationExtensions.UseSystemTextJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer},System.Text.Json.JsonSerializerOptions,System.Text.Encoding)">
            <summary>
            Configures Rebus to use .NET System.Text.Json to serialize messages, using the specified <see cref="T:System.Text.Json.JsonSerializerOptions"/> and <see cref="T:System.Text.Encoding"/>
            This allows you to customize almost every aspect of how messages are actually serialized/deserialized.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.SystemTextJsonSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.Serialization.ISerializer"/> that uses .NET System.Text.Json internally
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.SystemTextJsonSerializer.JsonUtf8ContentType">
            <summary>
            Proper content type when a message has been serialized with this serializer (or another compatible JSON serializer) and it uses the standard UTF8 encoding
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.SystemTextJsonSerializer.JsonContentType">
            <summary>
            Contents type when the content is JSON
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.SystemTextJsonSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.SystemTextJsonSerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ObjectSerializer">
            <summary>
            Generic serializer that happily serializes rich objects. Uses JSON.NET internally with full type information.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Serialize(System.Object)">
            <summary>
            Serializes the given object into a byte[]
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.SerializeToString(System.Object)">
            <summary>
            Serializes the given object into a string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes the given byte[] into an object
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given string into an object
            </summary>
        </member>
        <member name="T:Rebus.Subscriptions.ISubscriptionStorage">
            <summary>
            Abstraction that handles how subscriptions are stored
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Threading.AsyncBottleneck">
            <summary>
            The "bottleneck" is a wrapper around <see cref="T:System.Threading.SemaphoreSlim"/> that makes it easy to decrese the count of a semaphore,
            increasing it again after having used it.
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.#ctor(System.Int32)">
            <summary>
            Constructs the bottleneck, allowing for <paramref name="maxParallelOperationsToAllow"/> parallel operations
            to be performed
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.Enter(System.Threading.CancellationToken)">
            <summary>
            Grabs the semaphore and releases an <see cref="T:System.IDisposable"/> that will release it again when disposed
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTask">
            <summary>
            A task that will be executed periodically. Starts executing as soon as <see cref="M:Rebus.Threading.IAsyncTask.Start"/>
            is called, beginning with waiting the full interval before the first execution. Stops running when it is disposed.
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTaskFactory">
            <summary>
            Factory that is capable of creating lightweight async tasks for doing background work
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager">
            <summary>
            Helper that counts the number of parallel operations. Not reentrant, this bad boy is meant to be used from a single worker thread
            that may use it to count the number of async parallel operations waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.#ctor(System.Int32)">
            <summary>
            Constructs the container with the given max number of parallel async operations to allow
            </summary>
        </member>
        <member name="P:Rebus.Threading.ParallelOperationsManager.HasPendingTasks">
            <summary>
            Gets whether any async tasks are currently waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.TryBegin">
            <summary>
            Begins another async operation and returns an <see cref="T:System.IDisposable"/> that must be disposed in order to mark the end of the async operation
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager.ParallelOperation">
            <summary>
            Gets a disposable token for the parallel operation - the token indicates whether it's ok to continue
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.Dispose">
            <summary>
            Ends this parallel operation
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.CanContinue">
            <summary>
            Gets whether the token was successfully acquired
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTask"/> that uses a <see cref="T:System.Threading.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses a <see cref="T:System.Timers.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTask">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/>-based background timer thingie, that will periodically call an async <see cref="T:System.Func`1"/>
             </summary>
        </member>
        <member name="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses TPL to execute the background task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates a new TPL-based async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessage">
            <summary>
            Represents a message that was deferred and is now due. The message has some headers and a body and can be turned into
            a <see cref="T:Rebus.Messages.TransportMessage"/> by calling <see cref="M:Rebus.Timeouts.DueMessage.ToTransportMessage"/>. The due message can be constructed in a
            way that can perform an arbitrary action in order to mark the due message as successfully delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[],System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructs the due message with the given headers and body, storing the given <paramref name="completeAction"/> to be
            executed when the message's <see cref="M:Rebus.Timeouts.DueMessage.MarkAsCompleted"/> method is called.
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Headers">
            <summary>
            Gets the headers of this due message
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Body">
            <summary>
            Gets the body data of this due message
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.MarkAsCompleted">
            <summary>
            Marks the due message as successfully handled, which should probably be done when the message has been safely sent to the proper recipient
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.ToTransportMessage">
            <summary>
            Returns the headers and the body of this due message in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessagesResult">
            <summary>
            Represents the result of calling <see cref="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages"/> - contains zero or mode <see cref="T:Rebus.Timeouts.DueMessage"/> objects
            where each due message can be individually marked as successfully delivered 
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.#ctor(System.Collections.Generic.IEnumerable{Rebus.Timeouts.DueMessage},System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructs the result, wrapping the given list of due messages, performing the given action when the instance is disposed
            </summary>
        </member>
        <member name="F:Rebus.Timeouts.DueMessagesResult.Empty">
            <summary>
            Gets an empty due messages result
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.Complete">
            <summary>
            Completes the result by running the clean-up action
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.Dispose">
            <summary>
            Invokes the cleanup action
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.GetEnumerator">
            <summary>
            Returns all due messages from this result
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.ITimeoutManager">
            <summary>
            Abstraction for a mechanism that is capable of storing deferred messages until the time where it's appropriate for it to be delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.TimeoutsConfigurationExtensions">
            <summary>
            Configuration extensions for timeouts
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.TimeoutsConfigurationExtensions.UseExternalTimeoutManager(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String)">
            <summary>
            Configures Rebus to use another endpoint as the timeout manager
            </summary>
        </member>
        <member name="T:Rebus.Time.DefaultRebusTime">
            <summary>
            Default implementation of <see cref="T:Rebus.Time.IRebusTime"/> that returns the system clock time
            </summary>
        </member>
        <member name="P:Rebus.Time.DefaultRebusTime.Now">
            <summary>
            Gets the current time
            </summary>
        </member>
        <member name="T:Rebus.Time.IRebusTime">
            <summary>
            Represents time
            </summary>
        </member>
        <member name="P:Rebus.Time.IRebusTime.Now">
            <summary>
            Gets the current time
            </summary>
        </member>
        <member name="T:Rebus.Topic.DefaultTopicNameConvention">
            <summary>
            Default convention to name topics after their "short assembly-qualified type names", which is
            an assembly- and namespace-qualified type name without assembly version and public key token info.
            </summary>
        </member>
        <member name="M:Rebus.Topic.DefaultTopicNameConvention.GetTopic(System.Type)">
            <summary>
            Returns the default topic name based on the "short assembly-qualified type name", which is
            an assembly- and namespace-qualified type name without assembly version and public key token info.
            </summary>
        </member>
        <member name="T:Rebus.Topic.ITopicNameConvention">
            <summary>
            Defines the rules to name topics
            </summary>
        </member>
        <member name="M:Rebus.Topic.ITopicNameConvention.GetTopic(System.Type)">
            <summary>
            Returns the topic name based on type of message
            </summary>
        </member>
        <member name="T:Rebus.Transport.AbstractRebusTransport">
            <summary>
            Abstract transport implementation that implements the necessary logic to queue outgoing messages in memory,
            enabling batching and whatnot if desired when sending the messages at commit time
            </summary>
        </member>
        <member name="M:Rebus.Transport.AbstractRebusTransport.#ctor(System.String)">
            <summary>
            Creates the abstract Rebus transport with the given <paramref name="inputQueueName"/> (or NULL, if it's a one-way client)
            </summary>
        </member>
        <member name="M:Rebus.Transport.AbstractRebusTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Enqueues the <paramref name="message"/> by adding it to an in-mem list of outgoing messages
            </summary>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Transport.AbstractRebusTransport.CreateQueue(System.String)">
            <summary>
            Must implement the creation of a "queue" (whatever that means for the given transport implementation)
            </summary>
        </member>
        <member name="M:Rebus.Transport.AbstractRebusTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Must implement a receive operation, returning the next available message, or null of none could be found
            </summary>
        </member>
        <member name="M:Rebus.Transport.AbstractRebusTransport.SendOutgoingMessages(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},Rebus.Transport.ITransactionContext)">
            <summary>
            Implement this to send all outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Transport.AbstractRebusTransport.Address">
            <summary>
            Gets the transport's input queue address
            </summary>
        </member>
        <member name="T:Rebus.Transport.AmbientTransactionContext">
            <summary>
            Provides an "ambient" context for stashing away an instance that implements the current <see cref="T:Rebus.Transport.ITransactionContext"/>. The
            ambient transaction context is automatically preserved even though threads are changed etc.
            </summary>
        </member>
        <member name="F:Rebus.Transport.AmbientTransactionContext.DefaultSetter">
            <summary>
            Gets the default set function (which is using <see cref="T:System.Threading.AsyncLocal`1"/> to do its thing)
            </summary>
        </member>
        <member name="F:Rebus.Transport.AmbientTransactionContext.DefaultGetter">
            <summary>
            Gets the default set function (which is using <see cref="T:System.Threading.AsyncLocal`1"/> to do its thing)
            </summary>
        </member>
        <member name="P:Rebus.Transport.AmbientTransactionContext.Current">
            <summary>
            Gets/sets the current transaction context from the call context's logical data slot (which is automatically transferred to continuations when resuming
            awaited calls)
            </summary>
        </member>
        <member name="M:Rebus.Transport.AmbientTransactionContext.SetCurrent(Rebus.Transport.ITransactionContext)">
            <summary>
            Sets the current transaction context. Please note that in most cases, it is not necessary to set the context using this method
            - when using <see cref="T:Rebus.Transport.RebusTransactionScope"/> and <see cref="T:Rebus.Transport.RebusTransactionScopeSuppressor"/> the ambient transaction context
            is automatically set/unset when the object is created/disposed.
            </summary>
        </member>
        <member name="M:Rebus.Transport.AmbientTransactionContext.SetAccessors(System.Action{Rebus.Transport.ITransactionContext},System.Func{Rebus.Transport.ITransactionContext})">
            <summary>
            Sets the accessor functions used by Rebus to set the current transaction when executing handlers and
            getting the context by picking it up when sending messages
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransport">
            <summary>
            File system-based transport implementation
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.#ctor(System.String,System.String,Rebus.Transport.FileSystem.FileSystemTransportOptions,Rebus.Time.IRebusTime)">
            <summary>
            Creates the transport using the given <paramref name="baseDirectory"/> to store messages in the form of JSON files
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.CreateQueue(System.String)">
            <summary>
            Creates the "queue" with the given <paramref name="address"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message from the in-mem prefetch buffer, possibly trying to prefetch into the buffer first
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Initialize">
            <summary>
            Initializes the transport by ensuring that its own input queue exists
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.GetProperties(System.Threading.CancellationToken)">
            <summary>
            Gets additional information about the transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.SendOutgoingMessages(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the outgoing messages by writing them as files in the file system
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Dispose">
            <summary>
            Disposes the transport by releasing all currently locked messages
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the file system transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystem(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystemAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages, as a one-way client. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransportOptions">
            <summary>
            File system-based transport options
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportOptions.Prefetch(System.Int32)">
            <summary>
            Configures how many files to "prefetch", i.e. acquire file locks on
            </summary>
        </member>
        <member name="T:Rebus.Transport.ICanEagerCommit">
            <summary>
            Interface of a <see cref="T:Rebus.Transport.ITransactionContext"/> that can "eager commit", meaning that it'll carry out its internal commit behavior when told to do so.
            This finer level of control can be used in situations where the caller wants to ensure that the commit actions are carried out in a specific place.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ICanEagerCommit.CommitAsync">
            <summary>
            Commits the transaction context
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemNetwork">
            <summary>
            Defines a network that the in-mem transport can work on, functioning as a namespace for the queue addresses
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemNetwork.Queues">
            <summary>
            Retrieves all queues.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.#ctor(System.Boolean)">
            <summary>
            Constructs the in-mem network, optionally (if <paramref name="outputEventsToConsole"/> is set to true) outputting information
            about what is happening inside it to <see cref="P:System.Console.Out"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the in-mem network, outputting information about what is happening inside it to the given logger.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Reset">
            <summary>
            Resets the network (i.e. all queues and their messages are deleted)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Count">
            <summary>
            Get the total count of all queue messages
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Count(System.String)">
            <summary>
            Get the current queue message count of the specified <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Deliver(System.String,Rebus.Transport.InMem.InMemTransportMessage,System.Boolean)">
            <summary>
            Delivers the specified <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> to the address specified by <paramref name="destinationAddress"/>.
            If <paramref name="alwaysQuiet"/> is set to true, no events will ever be printed to <see cref="P:System.Console.Out"/>
            (can be used by an in-mem transport to return a message to a queue, as if there was a queue transaction that was rolled back)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetNextOrNull(System.String)">
            <summary>
            Gets the next message from the queue with the given <paramref name="inputQueueName"/>, returning null if no messages are available.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.HasQueue(System.String)">
            <summary>
            Returns whether the network has a queue with the specified name
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.CreateQueue(System.String)">
            <summary>
            Creates a queue on the network with the specified name
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetCount(System.String)">
            <summary>
            Gets the number of messages in the queue with the given <paramref name="address"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetMessages(System.String)">
            <summary>
            Gets the messages currently stored in the queue with the given <paramref name="address"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetSubscribers(System.String)">
            <summary>
            Gets the subscribers for the current topic
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.AddSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber with the given <paramref name="subscriberAddress"/> to the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.RemoveSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber with the given <paramref name="subscriberAddress"/> from the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransport">
            <summary>
            In-mem implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses one particular <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver messages. Can
            be used for in-process messaging and unit testing
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.#ctor(Rebus.Transport.InMem.InMemNetwork,System.String)">
            <summary>
            Creates the transport, using the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver/receive messages. This transport will have
            <paramref name="inputQueueAddress"/> as its input queue address, and thus will attempt to receive messages from the queue with that
            name out of the given <paramref name="network"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.CreateQueue(System.String)">
            <summary>
            Creates a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message from the queue identified by the configured <see cref="P:Rebus.Transport.AbstractRebusTransport.Address"/>, returning null if none was available
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.SendOutgoingMessages(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},Rebus.Transport.ITransactionContext)">
            <summary>
            Sends all outgoing messages by delivering them to the in-mem network
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Initialize">
            <summary>
            Initializes the transport by creating its own input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.GetProperties(System.Threading.CancellationToken)">
            <summary>
            Gets the number of messages waiting in the queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all subscribers for topic <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers <paramref name="subscriberAddress"/> as a susbcriber of <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters <paramref name="subscriberAddress"/> as a susbcriber of <paramref name="topic"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransport.IsCentralized">
            <summary>
            Gets whether this is a centralized subscription storage. Always returns true.
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the in-mem transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransport(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use in-mem message queues, delivering/receiving from the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/>
            If <paramref name="registerSubscriptionStorage"/> is TRUE, the in-mem network will be used as a subscription storage too, thus providing support for pub/sub without additional configuration.
            If <paramref name="registerSubscriptionStorage"/> is FALSE, another subscription storage can be registered via <code>.Subscriptions(s => s.StoreIn(...))</code>, which can be useful e.g. in testing scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransportAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork,System.Boolean)">
            <summary>
            Configures Rebus to use in-mem message queues, configuring this instance to be a one-way client.
            If <paramref name="registerSubscriptionStorage"/> is TRUE, the in-mem network will be used as a subscription storage too, thus providing support for pub/sub without additional configuration.
            If <paramref name="registerSubscriptionStorage"/> is FALSE, another subscription storage can be registered via <code>.Subscriptions(s => s.StoreIn(...))</code>, which can be useful e.g. in testing scenarios.
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessage">
            <summary>
            Represents a transport message that was delivered to an in-mem message queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.#ctor(Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the in-mem transport message from the given <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Age">
            <summary>
            Gets the age of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Headers">
            <summary>
            Gets the headers of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Body">
            <summary>
            Gets the body data of this in-mem transport message
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.ToTransportMessage">
            <summary>
            Returns this in-mem transport message's headers and body in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessageExtensions">
            <summary>
            Extensions that make it nice to work with <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> and <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessageExtensions.ToInMemTransportMessage(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a new <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> containing the headers and the body data of the <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransactionContext">
             <summary>
             Represents "a transaction", which can be either:
             
             (a) a unit of work where one or more messages get sent/published, or
             (b) a unit of work where a message is received, one or more messages get sent/published, and the received messages gets ACKed
            
             The sequence is
            
             (1) Receive incoming message
             (2) Call user code (i.e. handlers and such)
             (3) Commit
             (4) ACK
            
             where steps 1, 2, and 4 are simply omitted if we're talking about scenario (a).
             </summary>
        </member>
        <member name="P:Rebus.Transport.ITransactionContext.Items">
            <summary>
            Stash of items that can carry stuff for later use in the transaction
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnCommit(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is committed.
            This is a good place to enlist whatever work needs to be done when the message transaction is about to be completed.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnRollback(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is rolled back.
            This is a good place to enlist whatever rollback work needs to be done when the message transaction is about to be rolled back.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnAck(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})">
            <summary>
            Registers a callback to be invoked as an "ACK handler", which is what finishes a message transaction.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnNack(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})">
            <summary>
            Registers a callback to be invoked as a "NACK handler", which is what finishes a message transaction.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnDisposed(System.Action{Rebus.Transport.ITransactionContext})">
            <summary>
            Registers a listener to be called after the transaction is over
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.SetResult(System.Boolean,System.Boolean)">
            <summary>
            Sets the result of the transaction.
            If <paramref name="commit"/> is true, all commit callbacks registered with <see cref="M:Rebus.Transport.ITransactionContext.OnCommit(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})"/> will be invoked. If false, rollback callbacks registered with <see cref="M:Rebus.Transport.ITransactionContext.OnRollback(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})"/> will be invoked.
            If <paramref name="ack"/> is true, all ACK callbacks registered with <see cref="M:Rebus.Transport.ITransactionContext.OnAck(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})"/> will be invoked. If false, NACK callbacks registered with <see cref="M:Rebus.Transport.ITransactionContext.OnNack(System.Func{Rebus.Transport.ITransactionContext,System.Threading.Tasks.Task})"/> will be invoked. 
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransactionContextWithOwningBus">
            <summary>
            Extends <see cref="T:Rebus.Transport.ITransactionContext"/> with an "owning bus", which makes it possible for a bus instance to avoid enlisting
            its work in an ongoing transaction if it detects that it's another bus' context
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransactionContextWithOwningBus.OwningBus">
            <summary>
            Gets the owning bus instance
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransport">
            <summary>
            The transport is responsible for sending and receiving messages
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.CreateQueue(System.String)">
            <summary>
            Must create a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given <see cref="T:Rebus.Messages.TransportMessage"/> to the queue with the specified globally addressable name
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message (if any) from the transport's input queue <see cref="P:Rebus.Transport.ITransport.Address"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransport.Address">
            <summary>
            Gets the global address of the transport's input queue
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransportInspector">
            <summary>
            An optional extension that a transport can provide to allow for it to be interrogated
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransportInspector.GetProperties(System.Threading.CancellationToken)">
            <summary>
            Gets a dictionary of properties for the transport
            </summary>
        </member>
        <member name="T:Rebus.Transport.OutgoingTransportMessage">
            <summary>
            Represents one single transport messages for one particular destination
            </summary>
        </member>
        <member name="P:Rebus.Transport.OutgoingTransportMessage.TransportMessage">
            <summary>
            Gets the transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.OutgoingTransportMessage.DestinationAddress">
            <summary>
            Gets the destination address
            </summary>
        </member>
        <member name="M:Rebus.Transport.OutgoingTransportMessage.#ctor(Rebus.Messages.TransportMessage,System.String)">
            <summary>
            Constructs the outgoing message
            </summary>
        </member>
        <member name="T:Rebus.Transport.RebusTransactionScope">
            <summary>
            Default (async, as in: the <see cref="M:Rebus.Transport.RebusTransactionScope.CompleteAsync"/> method returns a <see cref="T:System.Threading.Tasks.Task"/> to be awaited) transaction scope 
            that sets up an ambient <see cref="T:Rebus.Transport.ITransactionContext"/> and removes
            it when the scope is disposed. Call <code>await scope.Complete();</code> in order to end the scope
            by committing any actions enlisted to be executed.
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScope.#ctor">
            <summary>
            Creates a new transaction context and mounts it on <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/>, making it available for Rebus
            to pick up. The context can also be retrieved simply via <see cref="P:Rebus.Transport.RebusTransactionScope.TransactionContext"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.RebusTransactionScope.TransactionContext">
            <summary>
            Gets the transaction context instance that this scope is holding
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScope.CompleteAsync">
            <summary>
            Ends the current transaction by either committing it or aborting it, depending on whether someone voted for abortion
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScope.Complete">
            <summary>
            Ends the current transaction by either committing it or aborting it, depending on whether someone voted for abortion (synchronous version)
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScope.Dispose">
            <summary>
            Disposes the transaction context and removes it from <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/> again
            </summary>
        </member>
        <member name="T:Rebus.Transport.RebusTransactionScopeSuppressor">
            <summary>
            Rebus transaction scope suppressor obviates the effect of an already active ambient Rebus transaction.
            E.g. inside Rebus handlers, this scope can be used if one wants to send/publish outgoing messages immediately,
            instead of enlisting them in the current handler's transaction context.
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScopeSuppressor.#ctor">
            <summary>
            Enters the scope by removing the currently entered ambient Rebus transaction context. The context
            will be restored, when the scope is disposed.
            </summary>
        </member>
        <member name="M:Rebus.Transport.RebusTransactionScopeSuppressor.Dispose">
            <summary>
            Exits the scope, restoring the previously active ambient transaction context (if any)
            </summary>
        </member>
        <member name="T:Rebus.Transport.TransactionContextExtensions">
            <summary>
            Nifty extensions to the transaction context, mostly working on the <see cref="P:Rebus.Transport.ITransactionContext.Items"/> dictionary
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrNull``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrThrow``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrAdd``1(Rebus.Transport.ITransactionContext,System.String,System.Func{``0})">
            <summary>
            Provides a shortcut to the transaction context's <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>,
            only as a typed version that 
            </summary>
        </member>
        <member name="T:Rebus.Transport.TransportInspectorPropertyKeys">
            <summary>
            Enumerates predefined keys which may/may not be used by a <see cref="T:Rebus.Transport.ITransportInspector"/> implementation to
            retport back information about the transport
            </summary>
        </member>
        <member name="F:Rebus.Transport.TransportInspectorPropertyKeys.QueueLength">
            <summary>
            Number of messages currently residing in the input queue
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorker">
            <summary>
            Represents a worker, which is a thing that is capable of doing work. It may correspond to a worker thread
            if the usual Rebus worker threads are used, but it may be possible to do other stuff as well
            </summary>
        </member>
        <member name="P:Rebus.Workers.IWorker.Name">
            <summary>
            Gets the name of the worker. Each worker will be named so that they can be recognized
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorker.Stop">
            <summary>
            Signals that the worker should try to stop itself because it will be thrown out and disposed in a little while
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorkerFactory">
            <summary>
            Factory responsible for creating a "worker"
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorkerFactory.CreateWorker(System.String)">
            <summary>
            Must create a new worker with the given name
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.#ctor(System.Collections.Generic.IEnumerable{System.TimeSpan},Rebus.Config.Options)">
            <summary>
            Constructs the backoff strategy with the given waiting times
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.Wait(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.WaitAsync(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.WaitNoMessage(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.WaitNoMessageAsync(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.WaitError(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.WaitErrorAsync(System.Threading.CancellationToken)">
            <param name="token"></param>
            <inheritdoc />
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy.Reset">
            <inheritdoc />
        </member>
        <member name="T:Rebus.Workers.ThreadPoolBased.IBackoffStrategy">
            <summary>
            Implements a strategy with which workers will back off in idle periods. Please note that the <see cref="T:Rebus.Workers.ThreadPoolBased.IBackoffStrategy"/>
            implementations must be reentrant!
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.Wait(System.Threading.CancellationToken)">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time a worker thread cannot continue because no more parallel operations are allowed to happen.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time a worker thread cannot continue because no more parallel operations are allowed to happen.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.WaitNoMessage(System.Threading.CancellationToken)">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.WaitNoMessageAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.WaitError(System.Threading.CancellationToken)">
            <summary>
            Blocks the thread for a (most likely longer) while, when an error has occurred
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.WaitErrorAsync(System.Threading.CancellationToken)">
            <summary>
            Blocks the thread for a (most likely longer) while, when an error has occurred
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.IBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorkerFactory"/> that uses worker threads to do synchronous receive of messages, dispatching
            received messages to the threadpool.
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory,Rebus.Pipeline.IPipelineInvoker,Rebus.Config.Options,System.Func{Rebus.Bus.RebusBus},Rebus.Bus.BusLifetimeEvents,Rebus.Workers.ThreadPoolBased.IBackoffStrategy,System.Threading.CancellationToken)">
            <summary>
            Creates the worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.CreateWorker(System.String)">
            <summary>
            Creates a new worker with the given <paramref name="workerName"/>
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.WaitForContinuationsToFinish">
            <summary>
            Blocks until all work has finished being done (i.e. waits for all message handling continuations to have been executed)
            </summary>
        </member>
        <member name="T:Rebus.Workers.TplBased.TplOptionsExtensions">
            <summary>
            Configuration extensions for an experimental TPL-based worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.TplBased.TplOptionsExtensions.UseTplToReceiveMessages(Rebus.Config.OptionsConfigurer)">
            <summary>
            Replaces the worker factory with one based on TPL
            </summary>
        </member>
        <member name="T:Rebus.Workers.TplBased.TplWorkerFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorkerFactory"/> that uses Task Parallel Library to receive messages.
            Must only be used with truly async transports (i.e. transports capable of doing non-blocking async
            receive operations), otherwise the thread pool might be robbed of its threads
            </summary>
        </member>
        <member name="M:Rebus.Workers.TplBased.TplWorkerFactory.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory,Rebus.Pipeline.IPipelineInvoker,Rebus.Config.Options,System.Func{Rebus.Bus.RebusBus},Rebus.Bus.BusLifetimeEvents,Rebus.Workers.ThreadPoolBased.IBackoffStrategy,System.Threading.CancellationToken)">
            <summary>
            Constructs the TPL worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.TplBased.TplWorkerFactory.WaitForContinuationsToFinish">
            <summary>
            Blocks until all work has finished being done (i.e. waits for all message handling continuations to have been executed)
            </summary>
        </member>
        <member name="M:Rebus.Workers.TplBased.TplWorkerFactory.CreateWorker(System.String)">
            <summary>
            Creates a new "worker thread"
            </summary>
        </member>
    </members>
</doc>
