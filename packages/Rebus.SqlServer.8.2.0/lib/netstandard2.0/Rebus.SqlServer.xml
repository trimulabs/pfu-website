<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus.SqlServer</name>
    </assembly>
    <members>
        <member name="T:Rebus.Config.Outbox.OutboxExtensions">
            <summary>
            Configuration extensions for SQL Server-based outbox
            </summary>
        </member>
        <member name="M:Rebus.Config.Outbox.OutboxExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.SqlServer.Outbox.IOutboxStorage},System.String,System.String)">
            <summary>
            Configures SQL Server as the outbox storage
            </summary>
        </member>
        <member name="M:Rebus.Config.Outbox.OutboxExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.SqlServer.Outbox.IOutboxStorage},System.String,Rebus.SqlServer.TableName)">
            <summary>
            Configures SQL Server as the outbox storage
            </summary>
        </member>
        <member name="M:Rebus.Config.Outbox.OutboxExtensions.UseOutbox(Rebus.Transport.RebusTransactionScope,Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction)">
            <summary>
            Enables the use of outbox on the <see cref="T:Rebus.Transport.RebusTransactionScope"/>. Will enlist all outgoing message operations in the
            <paramref name="connection"/>/<paramref name="transaction"/> passed to the method.
            </summary>
        </member>
        <member name="T:Rebus.Config.Outbox.SqlServerOutboxConfigurationExtensions">
            <summary>
            Configuration extensions for the experimental outbox support
            </summary>
        </member>
        <member name="M:Rebus.Config.Outbox.SqlServerOutboxConfigurationExtensions.Outbox(Rebus.Config.RebusConfigurer,System.Action{Rebus.Config.StandardConfigurer{Rebus.SqlServer.Outbox.IOutboxStorage}})">
            <summary>
            Configures Rebus to use an outbox.
            This will store a (message ID, source queue) tuple for all processed messages, and under this tuple any messages sent/published will
            also be stored, thus enabling truly idempotent message processing.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerDataBusConfigurationExtensions">
            <summary>
            Configuration extensions for SQL Server data bus
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean,System.Int32)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Config.SqlServerDataBusOptions,System.String)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerDataBusOptions">
            <summary>
            Describes options used to configure <seealso cref="T:Rebus.SqlServer.DataBus.SqlServerDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusOptions.#ctor(System.Func{Rebus.Injection.IResolutionContext,Rebus.SqlServer.IDbConnectionProvider})">
            <summary>
            Creates the options with the given cnnection provider factory
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Creates the options with the given <paramref name="connectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerDataBusOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the options via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerDataBusOptions.CommandTimeout">
            <summary>
            Configures the commanbd timeout
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerLeaseTransportOptions">
            <summary>
            Extends <seealso cref="T:Rebus.Config.SqlServerTransportOptions"/> with options specific to the <seealso cref="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerLeaseTransportOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Create an instance of the transport with a pre-created <seealso cref="T:Rebus.SqlServer.DbConnectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerLeaseTransportOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the transport connecting via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerLeaseTransportOptions.#ctor(System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}})">
            <summary>
            Creates an instance of the transport with utilising an <seealso cref="T:Rebus.SqlServer.IDbConnectionProvider"/> factory
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseInterval">
            <summary>
            If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseTolerance">
            <summary>
            If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerLeaseTransportOptions.AutomaticallyRenewLeases">
            <summary>
            If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <seealso cref="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseAutoRenewInterval"/>
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseAutoRenewInterval">
            <summary>
            If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <seealso cref="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseInterval"/> should be appropriate
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerLeaseTransportOptions.LeasedByFactory">
            <summary>
            If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerOptions">
            <summary>
            Options base class
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerOptions.ConnectionProviderFactory">
            <summary>
            Connection provider used to create connections for the transport
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerOptions.EnsureTablesAreCreated">
            <summary>
            If <c>false</c> tables will not be created and must be created outside of Rebus
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaConfigurationExtensions">
            <summary>
            Configuration extensions for sagas
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},Rebus.Config.SqlServerSagaStorageOptions,System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.UseSagaSerializer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},Rebus.SqlServer.Sagas.Serialization.ISagaSerializer)">
            <summary>
            Configures saga to use your own custom saga serializer
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaConfigurationExtensions.GetSagaTypeNamingStrategy(Rebus.Injection.IResolutionContext,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Get the registered implementation of <seealso cref="T:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy"/> or the default <seealso cref="T:Rebus.SqlServer.Sagas.LegacySagaTypeNamingStrategy"/> if one is not configured
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions">
            <summary>
            Configuration extensions for saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},Rebus.Config.SqlServerSagaSnapshotStorageOptions,System.String)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaSnapshotStorageOptions">
            <summary>
            Describes options used to configure <seealso cref="T:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotStorageOptions.#ctor(System.Func{Rebus.Injection.IResolutionContext,Rebus.SqlServer.IDbConnectionProvider})">
            <summary>
            Creates the options with the given cnnection provider factory
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotStorageOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Creates the options with the given <paramref name="connectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaSnapshotStorageOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the options via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSagaStorageOptions">
            <summary>
            Describes options used to configure <seealso cref="T:Rebus.SqlServer.Sagas.SqlServerSagaStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaStorageOptions.#ctor(System.Func{Rebus.Injection.IResolutionContext,Rebus.SqlServer.IDbConnectionProvider})">
            <summary>
            Creates the options with the given cnnection provider factory
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaStorageOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Creates the options with the given <paramref name="connectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSagaStorageOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the options via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions">
            <summary>
            Configuration extensions for subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerSubscriptionsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTimeoutManagerOptions">
            <summary>
            Describes options used to configure <seealso cref="T:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutManagerOptions.#ctor(System.Func{Rebus.Injection.IResolutionContext,Rebus.SqlServer.IDbConnectionProvider})">
            <summary>
            Creates the options with the given cnnection provider factory
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutManagerOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Creates the options with the given <paramref name="connectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutManagerOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the options via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTimeoutsConfigurationExtensions">
            <summary>
            Configuration extensions for configuring SQL persistence for sagas, subscriptions, and timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTimeoutsConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},Rebus.Config.SqlServerTimeoutManagerOptions,System.String)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the SQL transport
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Config.SqlServerLeaseTransportOptions,System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport. Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="transportOptions">Options controlling the transport setup</param>
            <param name="inputQueueName">Queue name to process messages from</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseModeAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Config.SqlServerLeaseTransportOptions)">
            <summary>
            Configures Rebus to use SQL Server as its transport in "one-way client mode" (i.e. as a send only endpoint). Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="transportOptions">Options controlling the transport setup</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Config.SqlServerTransportOptions,System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="transportOptions">Options controlling the transport setup</param>
            <param name="inputQueueName">Queue name to process messages from</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Config.SqlServerTransportOptions)">
            <summary>
            Configures Rebus to use SQLServer as its transport in "one-way client mode" (i.e. as a send-only endpoint). 
            </summary>
            <param name="configurer"></param>
            <param name="transportOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseModeAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String},System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport (in "one-way client mode", i.e. as a send-only endpoint). Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionString">Connection string</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
            <param name="enlistInAmbientTransaction">If <c>true</c> the connection will be enlisted in the ambient transaction if it exists, else it will create an SqlTransaction and enlist in it</param>
            <param name="ensureTablesAreCreated">If <c>true</c> tables for the queue will be created at run time. This means the connection provided to the transport must have schema modification rights. If <c>false</c> tables must be created externally before running</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseModeAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String})">
            <summary>
            Configures Rebus to use SQL Server as its transport (in "one-way client mode", i.e. as a send-only endpoint). The message table will automatically be created if it does not exist.
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionFactory">Factory to provide a new connection</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String},System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. Unlike the <c>UseSqlServer</c> calls the leased version of the SQL 
            Server transport does not hold a transaction open for the entire duration of the message handling. Instead it marks a
            message as being "leased" for a period of time. If the lease has expired then a worker is permitted to acquire the that
            message again and try reprocessing
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionString">Connection string</param>
            <param name="inputQueueName">Name of the queue, which must be a valid table table in SQL Server</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
            <param name="enlistInAmbientTransaction">If <c>true</c> the connection will be enlisted in the ambient transaction if it exists, else it will create an SqlTransaction and enlist in it</param>
            <param name="ensureTablesAreCreated">If <c>true</c> tables for the queue will be created at run time. This means the connection provided to the transport must have schema modification rights. If <c>false</c> tables must be created externally before running</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerInLeaseMode(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Boolean,System.Nullable{System.TimeSpan},System.Func{System.String},System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
            <param name="configurer">Static to extend</param>
            <param name="connectionFactory">Factory to provide a new connection</param>
            <param name="inputQueueName">Name of the queue, which must be a valid table table in SQL Server</param>
            <param name="leaseInterval">If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies</param>
            <param name="leaseTolerance">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance"/>. Workers will wait for this amount of time to elapse, beyond the lease time, before they pick up an already leased message.</param>
            <param name="automaticallyRenewLeases">If <c>true</c> then workers will automatically renew the lease they have acquired whilst they're still processing the message. This will occur in accordance with <paramref name="leaseAutoRenewInterval"/></param>
            <param name="leaseAutoRenewInterval">If <c>null</c> defaults to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>. Specifies how frequently a lease will be renewed whilst the worker is processing a message. Lower values decrease the chance of other workers processing the same message but increase DB communication. A value 50% of <paramref name="leaseInterval"/> should be appropriate</param>
            <param name="leasedByFactory">If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used</param>
            <param name="ensureTablesAreCreated">If <c>true</c> tables for the queue will be created at run time. This means the connection provided to the transport must have schema modification rights. If <c>false</c> tables must be created externally before running</param>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}})">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTransportOptions">
            <summary>
            Describes options used to configure the <seealso cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptions.#ctor(Rebus.SqlServer.IDbConnectionProvider)">
            <summary>
            Create an instance of the transport with a pre-created <seealso cref="T:Rebus.SqlServer.DbConnectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptions.#ctor(System.Func{Rebus.Injection.IResolutionContext,Rebus.SqlServer.IDbConnectionProvider})">
            <summary>
            Create an instance of the transport with a <paramref name="connectionProviderFactory"/> that can use the <see cref="T:Rebus.Injection.IResolutionContext"/> to look up things
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptions.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of the transport connecting via <paramref name="connectionString"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptions.#ctor(System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}})">
            <summary>
            Creates an instance of the transport with utilising an <seealso cref="T:Rebus.SqlServer.IDbConnectionProvider"/> factory
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptions.DisableNativeTimeoutManager">
            <summary>
            Disables the SQL transport's built-in ability to delay message delivery. This can be done if ther requirements for delayed messages
            exceeds what is convenient, as delayed messages will be sitting in the recipient's table until it is time to be consumed.
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerTransportOptions.InputQueueName">
            <summary>
            Name of the input queue to process. If <c>null</c> or whitespace the transport will be configured in one way mode (send only)
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerTransportOptions.AutoDeleteQueue">
            <summary>
            If true, the input queue table will be automatically dropped on transport disposal
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerTransportOptions.IsOneWayClient">
            <summary>
            If <c>true</c> the transport is configured in one way mode
            </summary>
        </member>
        <member name="P:Rebus.Config.SqlServerTransportOptions.ExpiredMessagesCleanupInterval">
            <summary>
            Gets the delay between executions of the background cleanup task
            </summary>
        </member>
        <member name="T:Rebus.Config.SqlServerTransportOptionsExtensions">
            <summary>
            Provides extensions for managing <seealso cref="T:Rebus.Config.SqlServerTransportOptions"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.AsOneWayClient``1(``0)">
            <summary>
            Flags the transport as only being used for sending
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.ReadFrom``1(``0,System.String)">
            <summary>
            Configures the transport to read from <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.OptOutOfTableCreation``1(``0)">
            <summary>
            Opts the client out of any table creation
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetEnsureTablesAreCreated``1(``0,System.Boolean)">
            <summary>
            Sets if table creation is allowed
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetAutoDeleteQueue``1(``0,System.Boolean)">
            <summary>
            Sets if table will be dropped automatically
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetExpiredMessagesCleanupInterval``1(``0,System.TimeSpan)">
            <summary>
            Sets the delay between executions of the background cleanup task
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetLeaseInterval``1(``0,System.Nullable{System.TimeSpan})">
            <summary>
            If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetLeaseTolerance``1(``0,System.Nullable{System.TimeSpan})">
            <summary>
            If <c>null</c> will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime"/>. Specifies how long a worker will request to keep a message. Higher values require less database communication but increase latency of a message being processed if a worker dies
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetAutomaticLeaseRenewal``1(``0,System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Enables or disables automatic lease renewal. If <paramref name="automaticallyRenewLeases"/> is <c>true</c> and <paramref name="automaticLeaseRenewInterval"/> is <c>null</c> it will default to <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.EnableAutomaticLeaseRenewal``1(``0,System.Nullable{System.TimeSpan})">
            <summary>
            Enables automatic lease renewal. If <paramref name="automaticLeaseRenewInterval"/> is <c>null</c> then <seealso cref="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal"/> will be used instead
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.DisableAutomaticLeaseRenewal``1(``0)">
            <summary>
            Disables automatic lease renewal. Message handlers that run longer than <seealso cref="P:Rebus.Config.SqlServerLeaseTransportOptions.LeaseInterval"/> would be processed by another worker even if the worker processing this message is healthy
            </summary>
        </member>
        <member name="M:Rebus.Config.SqlServerTransportOptionsExtensions.SetLeasedByFactory``1(``0,System.Func{System.String})">
            <summary>
            If non-<c>null</c> a factory which returns a string identifying this worker when it leases a message. If <c>null></c> the current machine name is used
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.AsyncHelpers.GetSync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="M:Rebus.SqlServer.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.SqlServer.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DataBus.SqlServerDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that uses SQL Server to store data
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory,Rebus.Time.IRebusTime,System.Int32)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Initialize">
            <summary>
            Initializes the SQL Server data storage.
            Will create the data table, unless this has been explicitly turned off when configuring the data storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Delete(System.String)">
            <summary>Deletes the attachment with the given ID</summary>
        </member>
        <member name="M:Rebus.SqlServer.DataBus.SqlServerDataBusStorage.Query(Rebus.DataBus.TimeRange,Rebus.DataBus.TimeRange)">
            <summary>
            Iterates through IDs of attachments that match the given <paramref name="readTime" /> and <paramref name="saveTime" /> criteria.
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DataBus.StreamWrapper">
            <summary>
            Wraps a stream and an action, calling the action when the stream is disposed
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionFactoryProvider">
            <summary>
            Implementation of <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/> that uses an async function to retrieve the <see cref="T:Rebus.SqlServer.IDbConnection"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionFactoryProvider.#ctor(System.Func{System.Threading.Tasks.Task{Rebus.SqlServer.IDbConnection}})">
            <summary>
            Creates the connection provider to use the specified <paramref name="connectionFactory"/> to create <see cref="T:Rebus.SqlServer.IDbConnection"/>s
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionFactoryProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionProvider">
            <summary>
            Implementation of <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionProvider.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Creates the connection provider with the given <paramref name="connectionString"/>.
            Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.SqlServer.DbConnectionProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbConnectionProvider.SqlConnectionOpening">
            <summary>
            Callback, which will be invoked every time a new connection is about to be opened
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbConnectionProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbConnectionWrapper">
            <summary>
            Wrapper of <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> that allows for either handling <see cref="T:Microsoft.Data.SqlClient.SqlTransaction"/> automatically, or for handling it externally
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.#ctor(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction,System.Boolean)">
            <summary>
            Constructs the wrapper, wrapping the given connection and transaction. It must be indicated with <paramref name="managedExternally"/> whether this wrapper
            should commit/rollback the transaction (depending on whether <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Complete"/> is called before <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Dispose"/>), or if the transaction
            is handled outside of the wrapper
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:Microsoft.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.GetColumns(System.String,System.String)">
            <summary>
            Gets information about the columns in the table given by <paramref name="dataTableName"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbConnectionWrapper.Dispose">
            <summary>
            Finishes the transaction and disposes the connection in order to return it to the connection pool. If the transaction
            has not been committed (by calling <see cref="M:Rebus.SqlServer.DbConnectionWrapper.Complete"/>), the transaction will be rolled back.
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.IDbConnection">
            <summary>
            Wrapper of <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> that allows for easily changing how transactions are handled, and possibly how <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> instances
            are reused by various services
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:Microsoft.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnection.GetColumns(System.String,System.String)">
            <summary>
            Gets information about the columns in the table given by [<paramref name="schema"/>].[<paramref name="dataTableName"/>]
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.DbColumn">
            <summary>
            Represents a SQL Server column
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbColumn.Name">
            <summary>
            Gets the name of the column
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.DbColumn.Type">
            <summary>
            Gets the SQL datatype of the column
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.DbColumn.#ctor(System.String,System.Data.SqlDbType)">
            <summary>
            Creates the column
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.IDbConnectionProvider">
            <summary>
            SQL Server database connection provider that allows for easily changing how the current <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> is obtained,
            possibly also changing how transactions are handled
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.IDbConnectionProvider.GetConnection">
            <summary>
            Gets a wrapper with the current <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> inside
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Outbox.IOutboxStorage">
            <summary>
            Outbox abstraction that enables truly idempotent message processing and store-and-forward for outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.IOutboxStorage.Save(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},System.String,System.String,System.String)">
            <summary>
            Stores the given <paramref name="outgoingMessages"/> as being the result of processing message with ID <paramref name="messageId"/>
            in the queue of this particular endpoint. If <paramref name="outgoingMessages"/> is an empty sequence, a note is made of the fact
            that the message with ID <paramref name="messageId"/> has been processed.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.IOutboxStorage.Save(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},Rebus.SqlServer.IDbConnection)">
            <summary>
            Stores the given <paramref name="outgoingMessages"/> using the given <paramref name="dbConnection"/>.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.IOutboxStorage.GetNextMessageBatch(System.String,System.Int32)">
            <summary>
            Gets the next message batch to be sent, possibly filtered by the given <paramref name="correlationId"/>. MIGHT return messages from other send operations in the rare
            case where there is a colission between correlation IDs. Returns from 0 to <paramref name="maxMessageBatchSize"/> messages in the batch.
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Outbox.OutboxConnection">
            <summary>
            Holds an open <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/>
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Outbox.OutboxConnection.Connection">
            <summary>
            Gets the connection
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Outbox.OutboxConnection.Transaction">
            <summary>
            Gets the current transaction
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Outbox.OutboxMessage">
            <summary>
            Represents one single message to be delivered to the transport
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessage.#ctor(System.Int64,System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Represents one single message to be delivered to the transport
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessage.ToTransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.SqlServer.Outbox.OutboxMessage.Headers"/> and <see cref="P:Rebus.SqlServer.Outbox.OutboxMessage.Body"/> wrapped in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Outbox.OutboxMessageBatch">
            <summary>
            Wraps a batch of <see cref="T:Rebus.SqlServer.Outbox.OutboxMessage"/>s along with a function that "completes" the batch (i.e. ensures that it will not be handled again -... e.g. by deleting it, or marking it as completed)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessageBatch.Empty(System.Action)">
            <summary>
            Gets an empty outbox message batch that doesn't complete anything and only performs some kind of cleanup when done
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessageBatch.#ctor(System.Func{System.Threading.Tasks.Task},System.Collections.Generic.IEnumerable{Rebus.SqlServer.Outbox.OutboxMessage},System.Action)">
            <summary>
            Creates the batch
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessageBatch.Complete">
            <summary>
            Marks the message batch as properly handled
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessageBatch.Dispose">
            <summary>
            Performs any cleanup actions necessary
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Outbox.OutboxMessageBatch.Count">
            <summary>
            Gets how many
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Outbox.OutboxMessageBatch.Item(System.Int32)">
            <summary>
            Gets by index
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.OutboxMessageBatch.GetEnumerator">
            <summary>
            Gets an enumerator for the wrapped sequence of <see cref="T:Rebus.SqlServer.Outbox.OutboxMessage"/>s
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Outbox.SqlServerOutboxStorage">
            <summary>
            Outbox implementation that uses a table in SQL Server to store the necessary outbox information
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.SqlServerOutboxStorage.#ctor(System.Func{Rebus.Transport.ITransactionContext,Rebus.SqlServer.IDbConnection},Rebus.SqlServer.TableName)">
            <summary>
            Creates the outbox storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.SqlServerOutboxStorage.Initialize">
            <summary>
            Initializes the outbox storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.SqlServerOutboxStorage.Save(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},System.String,System.String,System.String)">
            <summary>
            Stores the given <paramref name="outgoingMessages"/> as being the result of processing message with ID <paramref name="messageId"/>
            in the queue of this particular endpoint. If <paramref name="outgoingMessages"/> is an empty sequence, a note is made of the fact
            that the message with ID <paramref name="messageId"/> has been processed.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.SqlServerOutboxStorage.Save(System.Collections.Generic.IEnumerable{Rebus.Transport.OutgoingTransportMessage},Rebus.SqlServer.IDbConnection)">
            <summary>
            Stores the given <paramref name="outgoingMessages"/> using the given <paramref name="dbConnection"/>.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Outbox.SqlServerOutboxStorage.GetNextMessageBatch(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Rebus.SqlServer.Retrier">
            <summary>
            Mini-Polly 🙂
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.CachedSagaTypeNamingStrategy">
            <summary>
            Decorator for <seealso cref="T:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy"/> that caches the results in-case calculations are expensive
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.CachedSagaTypeNamingStrategy.#ctor(Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy)">
            <summary>
            Constructs a new instance which will defer actual naming to <paramref name="innerSagaTypeNamingStrategy"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.CachedSagaTypeNamingStrategy.GetSagaTypeName(System.Type,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy">
            <summary>
            Returns a string that uses a portion of the actual saga type name and appends the hash of the simple assembly qualified name of the hash. This is a balance between uniqueness and readable for diagnostic purposes
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.DefaultHumanReadableBytes">
            <summary>
            The number of bytes to leave as human readable if no value is specified
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.#ctor">
            <summary>
            Default constructor configured to use <seealso cref="F:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.DefaultHumanReadableBytes"/> number of human readable bytes
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.#ctor(System.Int32)">
            <summary>
            Constructs a new instance which uses <paramref name="numberOfHumanReadableBytes"/> of human readable bytes in the output
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.GetSagaTypeName(System.Type,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.Sagas.HumanReadableHashedSagaTypeNamingStrategy.GenerateHumanReadableHash(System.String,System.Type,System.Int32)">
            <summary>
            Generates a human readable hash that uses portions of <paramref name="humanReadableName"/> and the hash of <paramref name="sagaDataType"/>
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy">
            <summary>
            A contract for generating a type name for a saga as it'll be stored in the database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy.GetSagaTypeName(System.Type,System.Int32)">
            <summary>
            Generate a saga type name. Implementations should be pure/stable; for a given input the output should always be the same as it's used to find the saga in the database
            </summary>
            <param name="sagaDataType">Type a name is to be generated for</param>
            <param name="maximumLength">Maximum allowed length of the result. If the return is longer than this an exception will be thrown</param>
            <returns>A string representation of <paramref name="sagaDataType"/></returns>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.LegacySagaTypeNamingStrategy">
            <summary>
            Implementation of <seealso cref="T:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy"/> which uses legacy type naming; simply returning the name of the class
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.LegacySagaTypeNamingStrategy.GetSagaTypeName(System.Type,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Rebus.SqlServer.Sagas.Serialization.DefaultSagaSerializer">
            <summary>
            The default serializer for serializing sql saga data,
            Implement <seealso cref="T:Rebus.SqlServer.Sagas.Serialization.ISagaSerializer"/> to make your own custom serializer and register it using the UseSagaSerializer extension method.
            <seealso cref="M:Rebus.Config.SqlServerSagaConfigurationExtensions.UseSagaSerializer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},Rebus.SqlServer.Sagas.Serialization.ISagaSerializer)"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Serialization.DefaultSagaSerializer.SerializeToString(Rebus.Sagas.ISagaData)">
            <summary>
            Serializes the given ISagaData object into a string
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Serialization.DefaultSagaSerializer.DeserializeFromString(System.Type,System.String)">
            <summary>
            Deserializes the given string and type into a ISagaData object
            </summary>
            <param name="type"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.Serialization.ISagaSerializer">
            <summary>
            Serializer used to serialize and deserialize saga data
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Serialization.ISagaSerializer.SerializeToString(Rebus.Sagas.ISagaData)">
            <summary>
            Serializes the given ISagaData object into a string
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Serialization.ISagaSerializer.DeserializeFromString(System.Type,System.String)">
            <summary>
            Deserializes the given string and type into a ISagaData object
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.Sha512SagaTypeNamingStrategy">
            <summary>
            Implementation of <seealso cref="T:Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy"/> that uses as many bytes as it can from an SHA2-512 hash to generat ea name
            </summary>
            <remarks>Note: SHA-2 is seemingly safe to truncate <a href="https://crypto.stackexchange.com/questions/161/should-i-use-the-first-or-last-bits-from-a-sha-256-hash/163#163">Reference</a></remarks>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Sha512SagaTypeNamingStrategy.GetSagaTypeName(System.Type,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Sha512SagaTypeNamingStrategy.GetBase64EncodedPartialHash(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Returns a string of up to <paramref name="numberOfBytes"/> characters long that represent the Base64 encoded SHA2-512 hash of <paramref name="inputString"/>. The string will be encoded using <paramref name="encoding"/> first
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.Sha512SagaTypeNamingStrategy.GetMaximumBase64EncodedBytesThatFit(System.Int32)">
            <summary>
            Returns the number of bytes of bytes that can be encoded in Base64 and still fit in <paramref name="maximumSize"/>
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that uses a table in SQL Server to store saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Sagas.SqlServerSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that persists saga data as a Newtonsoft JSON.NET-serialized object to a table in SQL Server.
            Correlation properties are stored in a separate index table, allowing for looking up saga data instanes based on the configured correlation
            properties
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.SqlServer.Sagas.ISagaTypeNamingStrategy,Rebus.SqlServer.Sagas.Serialization.ISagaSerializer)">
            <summary>
            Constructs the saga storage, using the specified connection provider and tables for persistence.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Initialize">
            <summary>
            Initializes the storage by performing a check on the schema to see whether we should use
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.EnsureTablesAreCreated">
            <summary>
            Checks to see if the configured tables exist, creating them if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Queries the saga index for an instance with the given <paramref name="sagaDataType"/> with a
            a property named <paramref name="propertyName"/> and the value <paramref name="propertyValue"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Serializes the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Sagas.SqlServerSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given <see cref="T:Rebus.Sagas.ISagaData"/> and removes all its entries in the index
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.SqlServerMagic">
            <summary>
            Wraps some nice extension methods for <see cref="T:Microsoft.Data.SqlClient.SqlConnection"/> that makes it easy e.g. to query the schema
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.SqlServerMagic.PrimaryKeyViolationNumber">
            <summary>
            Error code that is emitted on PK violations
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.SqlServerMagic.ObjectDoesNotExistOrNoPermission">
            <summary>
            Error code that is emitted when something does not exist or the login's permissions do not allow the client to see it
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetTableNames(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetIndexNames(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all indexes in the current database
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.SqlServerMagic.GetColumns(Microsoft.Data.SqlClient.SqlConnection,System.String,System.String,Microsoft.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that persists subscriptions in a table in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the storage using the specified connection provider and table to store its subscriptions. If the subscription
            storage is shared by all subscribers and publishers, the <paramref name="isCentralized"/> parameter can be set to true
            in order to subscribe/unsubscribe directly instead of sending subscription/unsubscription requests
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.Initialize">
            <summary>
            Initializes the subscription storage by reading the lengths of the [topic] and [address] columns from SQL Server
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Subscriptions.SqlServerSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.TableName">
            <summary>
            Represents a (possibly schema-qualified) table name in SQL Server
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.TableName.Schema">
            <summary>
            Gets the schema name of the table
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.TableName.Name">
            <summary>
            Gets the table's name
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.#ctor(System.String,System.String)">
            <summary>
            Creates a <see cref="T:Rebus.SqlServer.TableName"/> object with the given schema and table names
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.Parse(System.String)">
            <summary>
            Parses the given name into a <see cref="T:Rebus.SqlServer.TableName"/>, defaulting to using the 'dbo' schema unless the name is schema-qualified.
            E.g. 'table' will result in a <see cref="T:Rebus.SqlServer.TableName"/> representing the '[dbo].[table]' table, whereas 'accounting.messages' will
            represent the '[accounting].[messages]' table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.ToString">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.Equals(Rebus.SqlServer.TableName)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Rebus.SqlServer.TableName.op_Equality(Rebus.SqlServer.TableName,Rebus.SqlServer.TableName)">
            <summary>
            Checks whether the two <see cref="T:Rebus.SqlServer.TableName"/> objects are equal (i.e. represent the same table)
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.TableName.op_Inequality(Rebus.SqlServer.TableName,Rebus.SqlServer.TableName)">
            <summary>
            Checks whether the two <see cref="T:Rebus.SqlServer.TableName"/> objects are not equal (i.e. do not represent the same table)
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that uses SQL Server to store messages until it's time to deliver them.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Time.IRebusTime)">
            <summary>
            Constructs the timeout manager, using the specified connection provider and table to store the messages until they're due.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.EnsureTableIsCreated">
            <summary>
            Creates the due messages table if necessary
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Defers the message to the time specified by <paramref name="approximateDueTime"/> at which point in time the message will be
            returned to whoever calls <see cref="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.GetDueMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Timeouts.SqlServerTimeoutManager.GetDueMessages">
            <summary>
            Gets messages due for delivery at the current time
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport">
            <summary>
            Similar to <seealso cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/> but does not maintain an active connection during message processing. Instead a "lease" is acquired for each message and only once "committed" is the message removed from the queue.
            <remarks>Note: This also changes the semantics of sending. Sent messages are queued in memory and are not committed to memory until the sender has committed</remarks>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.OutboundMessageBufferKey">
            <summary>
            Key for storing the outbound message buffer when performing <seealso cref="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)"/>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.LeasedByColumnSize">
            <summary>
            Size of the leasedby column
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTime">
            <summary>
            If not specified the default time messages are leased for
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseTolerance">
            <summary>
            If not specified the amount of tolerance workers will allow a message which has already been leased
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DefaultLeaseAutomaticRenewal">
            <summary>
            If not specified the amount of time the workers will automatically renew leases for actively handled messages
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory,Rebus.Time.IRebusTime,System.TimeSpan,System.Nullable{System.TimeSpan},System.Func{System.String},Rebus.Config.SqlServerLeaseTransportOptions)">
            <summary>
            Constructor
            </summary>
            <param name="connectionProvider">A <see cref="T:Rebus.SqlServer.IDbConnection"/> to obtain a database connection</param>
            <param name="inputQueueName">Name of the queue this transport is servicing</param>
            <param name="rebusLoggerFactory">A <seealso cref="T:Rebus.Logging.IRebusLoggerFactory"/> for building loggers</param>
            <param name="asyncTaskFactory">A <seealso cref="T:Rebus.Threading.IAsyncTaskFactory"/> for creating periodic tasks</param>
            <param name="rebusTime">A <seealso cref="T:Rebus.Time.IRebusTime"/> to provide the current time</param>
            <param name="leaseInterval">Interval of time messages are leased for</param>
            <param name="leaseTolerance">Buffer to allow lease overruns by</param>
            <param name="leasedByFactory">Factory for generating a string which identifies who has leased a message (eg. A hostname)</param>
            <param name="options">Additional options</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified logical destination address by adding it to the messages table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.ReceiveInternal(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Handle retrieving a message from the queue, decoding it, and performing any transaction maintenance.
            </summary>
            <param name="context">Tranasction context the receive is operating on</param>
            <param name="cancellationToken">Token to abort processing</param>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> or <c>null</c> if no message can be dequeued</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.AdditionalSchemaModifications(Rebus.SqlServer.TableName)">
            <summary>
            Provides an oppurtunity for derived implementations to also update the schema
            </summary>
            <param name="tableName"></param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.ApplyTransactionSemantics(Rebus.Transport.ITransactionContext,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Responsible for releasing the lease on message failure and removing the message on transaction commit
            </summary>
            <param name="context">Transaction context of the message processing</param>
            <param name="messageId">Identifier of the message currently being processed</param>
            <param name="cancellationToken">Token to abort processing</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.DeleteMessage(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Responsible for deleating the message on transaction commit
            </summary>
            <param name="messageId">Identifier of the message currently being processed</param>
            <param name="cancellationToken">Token to abort processing</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.GetOutboundMessageBuffer(Rebus.Transport.ITransactionContext)">
            <summary>
            Gets the outbound message buffer for sending of messages
            </summary>
            <param name="context">Transaction context containing the message bufffer</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerLeaseTransport.UpdateLease(Rebus.SqlServer.IDbConnectionProvider,System.String,System.Int64,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Updates a lease with a new leaseduntil value
            </summary>
            <param name="connectionProvider">Provider for obtaining a connection</param>
            <param name="tableName">Name of the table the messages are stored in</param>
            <param name="messageId">Identifier of the message whose lease is being updated</param>
            <param name="leaseInterval">New lease interval. If <c>null</c> the lease will be released</param>
            <param name="cancellationToken">Token to abort processing</param>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerLeaseTransport.AutomaticLeaseRenewer">
            <summary>
            Handles automatically renewing a lease for a given message
            </summary>
        </member>
        <member name="T:Rebus.SqlServer.Transport.SqlServerTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses SQL Server to do its thing
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.MagicExternalTimeoutManagerAddress">
            <summary>
            When a message is sent to this address, it will be deferred into the future!
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.MessagePriorityHeaderKey">
            <summary>
            Special message priority header that can be used with the <see cref="T:Rebus.SqlServer.Transport.SqlServerTransport"/>. The value must be an <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.CurrentConnectionKey">
            <summary>
            Key of the transport's currently used database connection. Can be retrieved from the context and used e.g.
            in a connection provider which is then in turn used in repositories and such. This way, "exactly once delivery" can actually be had.
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.DefaultExpiredMessagesCleanupInterval">
            <summary>
            Default delay between executing the background cleanup task
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.RecipientColumnSize">
            <summary>
            Size, in the database, of the recipient column
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.ConnectionProvider">
            <summary>
            Connection provider for obtaining a database connection
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.ReceiveTableName">
            <summary>
            Name of the table this transport is using for storage
            </summary>
        </member>
        <member name="F:Rebus.SqlServer.Transport.SqlServerTransport.Log">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.#ctor(Rebus.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory,Rebus.Time.IRebusTime,Rebus.Config.SqlServerTransportOptions)">
            <summary>
            Constructs the transport with the given <see cref="T:Rebus.SqlServer.IDbConnectionProvider"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Initialize">
            <summary>
            Initializes the transport by starting a task that deletes expired messages from the SQL table
            </summary>
        </member>
        <member name="P:Rebus.SqlServer.Transport.SqlServerTransport.Address">
            <summary>
            Gets the name that this SQL transport will use to query by when checking the messages table
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.CreateQueue(System.String)">
            <summary>
            Creates the table named after the given <paramref name="address"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.EnsureTableIsCreated">
            <summary>
            Checks if the table with the configured name exists - if not, it will be created
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.AdditionalSchemaModifications(Rebus.SqlServer.TableName)">
            <summary>
            Provides an opportunity for derived implementations to also update the schema
            </summary>
            <param name="tableName">Name of the table to create schema modifications for</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.EnsureTableIsDropped">
            <summary>
            Checks if the table with the configured name exists - if it is, it will be dropped
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.AdditionalSchemaModificationsOnDeleteQueue">
            <summary>
            Provides an oppurtunity for derived implementations to also update the schema when the queue is deleted automatically 
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified destination queue address by adding it to the queue's table.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message by querying the input queue table for a message with a recipient matching this transport's <see cref="P:Rebus.SqlServer.Transport.SqlServerTransport.Address"/>
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.ReceiveInternal(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Handle retrieving a message from the queue, decoding it, and performing any transaction maintenance.
            </summary>
            <param name="context">Tranasction context the receive is operating on</param>
            <param name="cancellationToken">Token to abort processing</param>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> or <c>null</c> if no message can be dequeued</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.ExtractTransportMessageFromReader(Microsoft.Data.SqlClient.SqlDataReader,System.Threading.CancellationToken)">
            <summary>
            Maps a <seealso cref="T:Microsoft.Data.SqlClient.SqlDataReader"/> that's read a result from the message table into a <seealso cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
            <returns>A <seealso cref="T:Rebus.Messages.TransportMessage"/> representing the row or <c>null</c> if no row was available</returns>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.GetDestinationAddressToUse(System.String,Rebus.Messages.TransportMessage)">
            <summary>
            Gets the address a message will actually be sent to. Handles deferred messsages.
            </summary>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.InnerSend(System.String,Rebus.Messages.TransportMessage,Rebus.SqlServer.IDbConnection)">
            <summary>
            Performs persistence of a message to the underlying table
            </summary>
            <param name="destinationAddress">Address the message will be sent to</param>
            <param name="message">Message to be sent</param>
            <param name="connection">Connection to use for writing to the database</param>
        </member>
        <member name="M:Rebus.SqlServer.Transport.SqlServerTransport.Dispose">
            <summary>
            Shuts down the background timer
            </summary>
        </member>
    </members>
</doc>
